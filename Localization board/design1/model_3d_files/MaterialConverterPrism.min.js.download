/*!
 * LMV v7.58.0
 *
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Forge Viewer Usage Limitations:
 *
 * The Autodesk Forge Viewer JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */(()=>{var e={43214:e=>{e.exports="\n#include <common>\n#ifndef RECIPROCAL_PI\n#define RECIPROCAL_PI 0.318309886\n#endif\n#define ONE 0.00390625\nuniform float opacity;\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\nuniform sampler2D importantSamplingRandomMap;\nuniform sampler2D importantSamplingSolidAngleMap;\n#if defined( PRISMOPAQUE )\nuniform vec3 opaque_albedo;\nuniform float opaque_f0;\nuniform vec3 opaque_luminance_modifier;\nuniform float opaque_luminance;\n#elif defined( PRISMMETAL )\nuniform vec3 metal_f0;\n#elif defined( PRISMLAYERED )\nuniform float layered_f0;\nuniform vec3 layered_diffuse;\nuniform float layered_fraction;\nuniform vec3 layered_bottom_f0;\nuniform float layered_roughness;\nuniform float layered_anisotropy;\nuniform float layered_rotation;\n#elif defined( PRISMTRANSPARENT )\nuniform float transparent_ior;\nuniform vec3 transparent_color;\nuniform float transparent_distance;\n#elif defined( PRISMGLAZING )\nuniform vec3 glazing_f0;\nuniform vec3 glazing_transmission_color;\nuniform float glazing_transmission_roughness;\n#elif defined( PRISMWOOD )\nuniform bool wood_fiber_cosine_enable;\nuniform int wood_fiber_cosine_bands;\nuniform vec4 wood_fiber_cosine_weights;\nuniform vec4 wood_fiber_cosine_frequencies;\nuniform bool wood_fiber_perlin_enable;\nuniform int wood_fiber_perlin_bands;\nuniform vec4 wood_fiber_perlin_weights;\nuniform vec4 wood_fiber_perlin_frequencies;\nuniform float wood_fiber_perlin_scale_z;\nuniform bool wood_growth_perlin_enable;\nuniform int wood_growth_perlin_bands;\nuniform vec4 wood_growth_perlin_weights;\nuniform vec4 wood_growth_perlin_frequencies;\nuniform float wood_latewood_ratio;\nuniform float wood_earlywood_sharpness;\nuniform float wood_latewood_sharpness;\nuniform float wood_ring_thickness;\nuniform bool wood_earlycolor_perlin_enable;\nuniform int wood_earlycolor_perlin_bands;\nuniform vec4 wood_earlycolor_perlin_weights;\nuniform vec4 wood_earlycolor_perlin_frequencies;\nuniform vec3 wood_early_color;\nuniform bool wood_use_manual_late_color;\nuniform vec3 wood_manual_late_color;\nuniform bool wood_latecolor_perlin_enable;\nuniform int wood_latecolor_perlin_bands;\nuniform vec4 wood_latecolor_perlin_weights;\nuniform vec4 wood_latecolor_perlin_frequencies;\nuniform float wood_late_color_power;\nuniform bool wood_diffuse_perlin_enable;\nuniform int wood_diffuse_perlin_bands;\nuniform vec4 wood_diffuse_perlin_weights;\nuniform vec4 wood_diffuse_perlin_frequencies;\nuniform float wood_diffuse_perlin_scale_z;\nuniform bool wood_use_pores;\nuniform int wood_pore_type;\nuniform float wood_pore_radius;\nuniform float wood_pore_cell_dim;\nuniform float wood_pore_color_power;\nuniform float wood_pore_depth;\nuniform bool wood_use_rays;\nuniform float wood_ray_color_power;\nuniform float wood_ray_seg_length_z;\nuniform float wood_ray_num_slices;\nuniform float wood_ray_ellipse_z2x;\nuniform float wood_ray_ellipse_radius_x;\nuniform bool wood_use_latewood_bump;\nuniform float wood_latewood_bump_depth;\nuniform bool wood_use_groove_roughness;\nuniform float wood_groove_roughness;\nuniform float wood_diffuse_lobe_weight;\nuniform sampler2D permutationMap;\nuniform sampler2D gradientMap;\nuniform sampler2D perm2DMap;\nuniform sampler2D permGradMap;\nuniform vec4 wood_ring_fraction;\nuniform vec2 wood_fall_rise;\n#endif\n#ifdef USE_TILING\nuniform mat4 tilingOverallTransform;\nuniform sampler2D TilingMap;\nuniform mat3 TilingMap_texMatrix;\nuniform vec4 uv2tile;\nuniform vec4 tile2uv;\nuniform vec2 tileAlignOffset;\nuniform mat4 tilingUVTransform;\n#ifdef USE_TILING_NORMAL\nuniform sampler2D TilingNormalMap;\nuniform mat3 TilingNormalMap_texMatrix;\n#endif\n#ifdef USE_TILING_RANDOM\nuniform sampler2D TilingRandomMap;\nuniform mat3 TilingRandomMap_texMatrix;\nuniform vec2 tilingRandomAxisS;\nuniform vec2 tilingRandomAxisT;\nuniform vec2 tilingRandomAlignmentOffset;\n#endif\n#endif\nuniform float envExponentMin;\nuniform float envExponentMax;\nuniform float envExponentCount;\n#include <env_sample>\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\n#include <tonemap>\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include <id_decl_frag>\n#include <theming_decl_frag>\n#include <shadowmap_decl_frag>\n#ifdef USE_FOG\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#if defined( USE_SURFACE_ALBEDO_MAP ) || defined( USE_SURFACE_ROUGHNESS_MAP ) || defined( USE_SURFACE_CUTOUT_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_OPAQUE_ALBEDO_MAP ) || defined( USE_OPAQUE_F0_MAP ) || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP ) || defined( USE_LAYERED_BOTTOM_F0_MAP ) || defined( USE_LAYERED_F0_MAP ) || defined( USE_LAYERED_DIFFUSE_MAP ) || defined( USE_LAYERED_FRACTION_MAP ) || defined( USE_LAYERED_ROUGHNESS_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_METAL_F0_MAP ) || defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )\n    #define USE_MAP\n#endif\n#if defined(USE_MAP) || defined(USE_TILING)\nvarying vec2 vUv;\n#endif\n#if defined(PRISMWOOD) && !defined(NO_UVW)\nvarying vec3 vUvw;\n#endif\n#if defined( USE_SURFACE_ALBEDO_MAP )\n    uniform sampler2D surface_albedo_map;\n    uniform mat3 surface_albedo_map_texMatrix;\n    uniform bool surface_albedo_map_invert;\n#endif\n#if defined( USE_SURFACE_ROUGHNESS_MAP )\n    uniform sampler2D surface_roughness_map;\n    uniform mat3 surface_roughness_map_texMatrix;\n    uniform bool surface_roughness_map_invert;\n#endif\n#if defined( USE_SURFACE_CUTOUT_MAP )\n    uniform sampler2D surface_cutout_map;\n    uniform mat3 surface_cutout_map_texMatrix;\n    uniform bool surface_cutout_map_invert;\n#endif\n#if defined( USE_SURFACE_ANISOTROPY_MAP )\n    uniform sampler2D surface_anisotropy_map;\n    uniform mat3 surface_anisotropy_map_texMatrix;\n    uniform bool surface_anisotropy_map_invert;\n#endif\n#if defined( USE_SURFACE_ROTATION_MAP )\n    uniform sampler2D surface_rotation_map;\n    uniform mat3 surface_rotation_map_texMatrix;\n    uniform bool surface_rotation_map_invert;\n#endif\n#if defined( USE_OPAQUE_ALBEDO_MAP )\n    uniform sampler2D opaque_albedo_map;\n    uniform mat3 opaque_albedo_map_texMatrix;\n    uniform bool opaque_albedo_map_invert;\n#endif\n#if defined( USE_OPAQUE_F0_MAP )\n    uniform sampler2D opaque_f0_map;\n    uniform mat3 opaque_f0_map_texMatrix;\n    uniform bool opaque_f0_map_invert;\n#endif\n#if defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )\n    uniform sampler2D opaque_luminance_modifier_map;\n    uniform mat3 opaque_luminance_modifier_map_texMatrix;\n    uniform bool opaque_luminance_modifier_map_invert;\n#endif\n#if defined( USE_LAYERED_BOTTOM_F0_MAP )\n    uniform sampler2D layered_bottom_f0_map;\n    uniform mat3 layered_bottom_f0_map_texMatrix;\n    uniform bool layered_bottom_f0_map_invert;\n#endif\n#if defined( USE_LAYERED_F0_MAP )\n    uniform sampler2D layered_f0_map;\n    uniform mat3 layered_f0_map_texMatrix;\n    uniform bool layered_f0_map_invert;\n#endif\n#if defined( USE_LAYERED_DIFFUSE_MAP )\n    uniform sampler2D layered_diffuse_map;\n    uniform mat3 layered_diffuse_map_texMatrix;\n    uniform bool layered_diffuse_map_invert;\n#endif\n#if defined( USE_LAYERED_FRACTION_MAP )\n    uniform sampler2D layered_fraction_map;\n    uniform mat3 layered_fraction_map_texMatrix;\n    uniform bool layered_fraction_map_invert;\n#endif\n#if defined( USE_LAYERED_ROUGHNESS_MAP )\n    uniform sampler2D layered_roughness_map;\n    uniform mat3 layered_roughness_map_texMatrix;\n    uniform bool layered_roughness_map_invert;\n#endif\n#if defined( USE_LAYERED_ANISOTROPY_MAP )\n    uniform sampler2D layered_anisotropy_map;\n    uniform mat3 layered_anisotropy_map_texMatrix;\n    uniform bool layered_anisotropy_map_invert;\n#endif\n#if defined( USE_LAYERED_ROTATION_MAP )\n    uniform sampler2D layered_rotation_map;\n    uniform mat3 layered_rotation_map_texMatrix;\n    uniform bool layered_rotation_map_invert;\n#endif\n#if defined( USE_METAL_F0_MAP )\n    uniform sampler2D metal_f0_map;\n    uniform mat3 metal_f0_map_texMatrix;\n    uniform bool metal_f0_map_invert;\n#endif\n#if defined( USE_GLAZING_F0_MAP )\n    uniform sampler2D glazing_f0_map;\n    uniform mat3 glazing_f0_map_texMatrix;\n    uniform bool glazing_f0_map_invert;\n#endif\n#if defined( USE_GLAZING_TRANSMISSION_ROUGHNESS_MAP )\n    uniform sampler2D glazing_transmission_roughness_map;\n    uniform mat3 glazing_transmission_roughness_map_texMatrix;\n    uniform bool glazing_transmission_roughness_map_invert;\n#endif\n#if defined( USE_GLAZING_TRANSMISSION_COLOR_MAP )\n    uniform sampler2D glazing_transmission_color_map;\n    uniform mat3 glazing_transmission_color_map_texMatrix;\n    uniform bool glazing_transmission_color_map_invert;\n#endif\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\n    uniform sampler2D wood_curly_distortion_map;\n    uniform mat3 wood_curly_distortion_map_texMatrix;\n    uniform bool wood_curly_distortion_map_invert;\n#endif\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nuniform bool wood_curly_distortion_enable;\nuniform float wood_curly_distortion_scale;\n#endif\n#if defined( USE_SURFACE_NORMAL_MAP )\n    uniform sampler2D surface_normal_map;\n    uniform mat3 surface_normal_map_texMatrix;\n    uniform vec2 surface_normal_map_bumpScale;\n    uniform int surface_normal_map_bumpmapType;\n#endif\n#if defined( USE_LAYERED_NORMAL_MAP )\n    uniform sampler2D layered_normal_map;\n    uniform mat3 layered_normal_map_texMatrix;\n    uniform vec2 layered_normal_map_bumpScale;\n    uniform int layered_normal_map_bumpmapType;\n#endif\nfloat SRGBToLinearComponent(float color) {\n    float result = color;\n    if (result<=0.04045)\n        result *= 0.07739938;\n    else\n        result = pow(abs((result+0.055)*0.947867298), 2.4);\n    return result;\n}\nvec3 SRGBToLinear(vec3 color) {\n    vec3 result = color;\n    result.x = SRGBToLinearComponent(result.x);\n    result.y = SRGBToLinearComponent(result.y);\n    result.z = SRGBToLinearComponent(result.z);\n    return result;\n}\n#if defined( USE_ENVMAP )\nuniform float envMapExposure;\nuniform samplerCube envMap;\n#endif\n#include <normal_map>\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined ( PRISMWOODBUMP )\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#if defined( PRISMWOODBUMP )\nvarying vec3 vtNormal;\nvarying mat3 mNormalMatrix;\n#endif\n#endif\n#if defined( USE_ENVMAP )\nvec3 sampleReflection(vec3 N, vec3 V, float mipIndex) {\n    vec3 dir = (2.0 * dot(V, N)) * N - V;\n    dir = adjustLookupVector(mat3(viewMatrixInverse) * dir);\n#ifdef ENV_GAMMA\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\n    return GammaDecode(envTexColor, envMapExposure);\n#elif defined(ENV_RGBM)\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\n    return RGBMDecode(envTexColor, envMapExposure);\n#else\n    vec4 envTexColor = textureCube( envMap, dir );\n    vec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\n    cubeColor *= cubeColor;\n#endif\n    return cubeColor;\n#endif\n}\n#endif\n#include <hatch_pattern>\n#if defined( USE_ENVMAP ) && defined( USE_IRRADIANCEMAP )\nuniform samplerCube irradianceMap;\nvec3 sampleNormal(vec3 normal) {\n    vec3 worldNormal = mat3(viewMatrixInverse) * normal;\n    vec3 irradiance = sampleIrradianceMap(worldNormal, irradianceMap, envMapExposure);\n    irradiance = applyEnvShadow(irradiance, worldNormal);\n    return irradiance;\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\nfloat sqr(float x) {return x*x;}\nfloat aSqrd(float maxAlphaSqr, float cosTheta)\n{\n    if (abs(cosTheta) < 1e-10)\n    {\n        return 1e10;\n    }\n    float tan2 = 1.0/sqr(cosTheta) - 1.0;\n    return maxAlphaSqr * tan2;\n}\nvec3 Fresnel_Schlick(vec3 f0, float cosAngle)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 Fresnel_Rough(vec3 f0, float cosAngle, float alpha)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\nfloat IORToReflectance(float ior)\n{\n    return sqr((1.0 - ior)/(1.0 + ior));\n}\nvec2 RoughnessToAlpha(float roughness, float anisotropy)\n{\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nfloat AlphaToPhong(float alpha)\n{\n    return max(0.0, 2.56/alpha - 7.0);\n}\nfloat ExponentToReflMipIndex(float exponent)\n{\n    float targetLog = log2(exponent);\n    float minLog = log2(envExponentMin);\n    float maxLog = log2(envExponentMax);\n    float deltaLog = clamp(targetLog - minLog, 0.0, maxLog - minLog);\n    float level = clamp((1.0-(deltaLog + 0.5) / envExponentCount), 0.0, 1.0) * 6.0;\n    return level;\n}\n#include <prism_wood>\n#if defined( ENABLEIMPORTANTSAMPLING ) && (defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ))\n#define IMPORTANTSAMPLING\n#endif\n#if defined( IMPORTANTSAMPLING )\n#define SAMPLECOUNT 32\nvec2 Hammersley(int index)\n{\n    float u = (float(index) + 0.5) / 32.0;\n    float v = 0.5;\n    float noise = texture2D(importantSamplingRandomMap, vec2(u, v), 0.0).r;\n   return vec2(2.0 * PI * float(index/SAMPLECOUNT), noise);\n}\nvec3 ImportanceSampleAnisotropicGGX(int index, vec2 alpha, vec3 N, vec3 Tu, vec3 Tv)\n{\n    vec2 uniformSample2D = Hammersley(index);\n    float coef = sqrt(uniformSample2D.y / (1.0 - uniformSample2D.y));\n    float sinSigma, cosSigma;\n    sinSigma = sin(uniformSample2D.x);\n    cosSigma = cos(uniformSample2D.x);\n    vec3 H = coef * ((alpha.x * cosSigma) * Tu + (alpha.y * sinSigma) * Tv) + N;\n    H = normalize(H);\n    return H;\n}\nfloat ComputePDF(vec2 alpha, float NdotH, float HdotTu, float HdotTv, float VdotH)\n{\n    float factor1 = HdotTu / alpha.x;\n    float factor2 = HdotTv / alpha.y;\n    float factor3 = factor1 * factor1 + factor2 * factor2 + NdotH * NdotH;\n    float factor = factor3 * factor3 * alpha.x * alpha.y * VdotH * 4.0 * PI;\n    if (factor > 0.0)\n    {\n        return (NdotH / factor);\n    }\n    else\n    {\n        return 0.0;\n    }\n}\n#define INVFACESIZE 0.0078125\nfloat DirectionToSolidAngle(vec3 dir)\n{\n    dir = abs(dir);\n    float first = min(dir.x, dir.y);\n    float temp = max(dir.x, dir.y);\n    float second = min(temp, dir.z);\n    float third = max(temp, dir.z);\n    first /= third;\n    second /= third;\n    float u = (first+1.0)/2.0;\n    float v = (second + 1.0) / 2.0;\n    float solidAngle = texture2D(importantSamplingSolidAngleMap, vec2(u, v), 0.0).r * 0.000255;\n    return solidAngle;\n}\nfloat Smith_GGX(float value)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + value));\n}\nvec2 RoughnessAnisotropyToAlpha(float roughness, float anisotropy)\n{\n    float aspect = sqrt(1.0 - 0.9 * anisotropy);\n    vec2 alpha = vec2(roughness * roughness / aspect, roughness * roughness * aspect);\n    return alpha;\n}\nvec3 ImportanceSamplingSpecular(float angle, vec3 reflectance, float roughness, float anisotropy, vec3 V, vec3 N, vec3 Tu, vec3 Tv)\n{\n    vec3 specular = vec3(0.0);\n    float radAngle;\n    if (anisotropy < 1e-10)\n    {\n        radAngle = 0.0;\n    }\n    else\n    {\n        radAngle = -PI * angle;\n    }\n    vec2 alpha = RoughnessAnisotropyToAlpha(roughness, anisotropy);\n    float alpha2 = max(alpha.x * alpha.x, alpha.y * alpha.y);\n    float NdotV = dot(N, V);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    vec2 sincosTheta;\n    sincosTheta.x = sin(radAngle);\n    sincosTheta.y = cos(radAngle);\n    vec3 Tu1, Tv1;\n    Tu1 = sincosTheta.y * Tu - sincosTheta.x * Tv;\n    Tv1 = sincosTheta.x * Tu + sincosTheta.y * Tv;\n    vec3 H;\n    vec3 sampleLightIntensity;\n    vec3 L;\n    float effectiveSample = 0.0;\n    for (int i = 0; i < SAMPLECOUNT; i++)\n    {\n        H = ImportanceSampleAnisotropicGGX(i, alpha, N, Tu1, Tv1);\n        float VdotH = dot(V, H);\n        L = 2.0 * VdotH * H - V;\n        float NdotH = dot(N, H);\n        float NdotL = dot(N, L);\n        if (NdotL >= 0.0 && NdotV > 0.0 && NdotH > 0.0)\n        {\n            float alpha2NL = aSqrd(alpha2, NdotL);\n            float HdotTu = dot(H, Tu1);\n            float HdotTv = dot(H, Tv1);\n            float pdf = ComputePDF(alpha, NdotH, HdotTu, HdotTv, VdotH);\n            float mipmapLevel = 0.0;\n            if (pdf > 0.0)\n            {\n                mipmapLevel = 0.3 * log2(1.0 / (float(SAMPLECOUNT) * pdf * DirectionToSolidAngle(L)));\n            }\n            mipmapLevel = clamp(mipmapLevel, 0.0, 4.0);\n            L = normalize(L);\n            sampleLightIntensity = sampleReflection(L, L, mipmapLevel).rgb;\n            float G = Smith_GGX(alpha2NL) * Smith_GGX(alpha2NV);\n            vec3 F = Fresnel_Schlick(reflectance, VdotH);\n            float factor = G * VdotH / (NdotH * NdotV);\n            if (factor >= 0.0)\n            {\n                specular += abs(sampleLightIntensity * F * factor);\n                effectiveSample += 1.0;\n            }\n        }\n    }\n    if (effectiveSample > 0.0)\n    {\n        specular /= effectiveSample;\n    }\n    return specular;\n}\n#endif\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvec3 DiffuseLobe(vec3 diffuseColor)\n{\n    return diffuseColor * RECIPROCAL_PI;\n}\nvec3 Rotate(vec3 vec, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\nfloat NDF_GGX(float alphaU, float alphaV, vec3 normal)\n{\n    float nx2 = sqr(normal.x);\n    float ny2 = sqr(normal.y);\n    float nz2 = sqr(normal.z);\n    float scale = 1.0/(alphaU * alphaV * PI);\n    return scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);\n}\nfloat G1_GGX(float aSqrd)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\nvec3 MicrofacetLobe(\n        vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        float roughness, float anisotropy, float rotation, vec3 reflectance)\n{\n    vec2 alpha = RoughnessToAlpha(roughness, anisotropy);\n    Hlocal = Rotate(Hlocal, rotation);\n    vec3 F = Fresnel_Schlick(reflectance, VdotH);\n    float D = NDF_GGX(alpha.x, alpha.y, Hlocal);\n    float alpha2 = max(sqr(alpha.x), sqr(alpha.y));\n    float alpha2NL = aSqrd(alpha2, NdotL);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    float G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);\n    return max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));\n}\n#if defined( PRISMOPAQUE )\nvec3 BRDF_Opaque(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        float opaqueF0, vec3 opaqueAlbedo)\n{\n    vec3 diffuse = DiffuseLobe(opaqueAlbedo);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, vec3(opaqueF0));\n    return (specular+diffuse)*NdotL;\n}\n#elif defined( PRISMMETAL )\nvec3 BRDF_Metal(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        vec3 metalF0)\n{\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, metalF0);\n    return specular*NdotL;\n}\n#elif defined( PRISMLAYERED )\nvec3 BRDF_Layered(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 Hlocal2, float N2dotL, float N2dotH, float N2dotV,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,\n        float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 Fl = Fresnel_Schlick(vec3(layeredF0), NdotL);\n    vec3 Fv = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    vec3 amount = (1.0 - Fl) * (1.0 - Fv);\n    vec3 topSpecular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n            vec3(layeredF0));\n    vec3 topDiffuse = DiffuseLobe(layeredDiffuse);\n    vec3 botSpecular = MicrofacetLobe(\n            Hlocal2, N2dotL, N2dotH, N2dotV, VdotH,\n            layeredRoughness, layeredAnisotropy, layeredRotation,\n            bottom_f0);\n    return topSpecular*NdotL + amount * mix(topDiffuse*NdotL, botSpecular*N2dotL, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 BRDF_Transparent(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, reflectance);\n    return specular*NdotL;\n}\n#elif defined( PRISMGLAZING )\nvec3 BRDF_Glazing(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        vec3 glazingF0, vec3 glazingTransmissionColor, float glazingIlluminance)\n{\n    vec3 diffuse = DiffuseLobe(glazingTransmissionColor - vec3(glazingIlluminance, glazingIlluminance, glazingIlluminance));\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, glazingF0);\n    return (specular+diffuse)*NdotL;\n}\n#elif defined( PRISMWOOD )\nvec3 BRDF_Wood(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse)\n{\n    vec3 diffuse = DiffuseLobe(woodDiffuse);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, 0.0, 0.0, vec3(0.04));\n    return (specular+diffuse)*NdotL;\n}\n#endif\n#endif\n#if defined( USE_ENVMAP )\n#if defined( PRISMOPAQUE )\nvec3 Environment_Opaque(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float opaqueF0, vec3 opaqueAlbedo, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 T)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(vec3(opaqueF0), NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(opaqueF0), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F* surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * opaqueAlbedo * envIrradiance;\n    return diffuse + specular;\n}\n#elif defined( PRISMMETAL )\nvec3 Environment_Metal(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 metalF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, metalF0, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 F = Fresnel_Rough(metalF0, NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n    return specular;\n}\n#elif defined( PRISMLAYERED )\nvec3 Environment_Layered(vec3 N, vec3 V, float NdotV, vec3 N2, float N2dotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float layeredF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv, vec3 layeredDiffuse, float layeredRoughness,\n        float layeredAnisotropy, float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 F = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n#if defined( IMPORTANTSAMPLING )\n    vec3 topSpecular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(layeredF0), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 topSpecular = F * surfaceAlbedo * envSpecular;\n#endif\n    vec3 amount = (1.0 - F);\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 topDiffuse = layeredDiffuse * envIrradiance;\n#if defined( IMPORTANTSAMPLING )\n    vec3 botSpecular = ImportanceSamplingSpecular(layeredRotation, bottom_f0, layeredRoughness, layeredAnisotropy, V, N2, Tu, Tv);\n#else\n    alpha = RoughnessToAlpha(layeredRoughness, 0.0).x;\n    exponent = AlphaToPhong(alpha);\n    reflMipIndex = ExponentToReflMipIndex(exponent);\n    envSpecular = sampleReflection(N2, V, reflMipIndex);\n    F = Fresnel_Rough(bottom_f0, N2dotV, alpha);\n    vec3 botSpecular = F * envSpecular;\n#endif\n    return topSpecular + amount * mix(topDiffuse, botSpecular, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 Environment_Transparent(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(reflectance, NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, reflectance, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 color = F * surfaceRoughness * transparent_color * envIrradiance;\n    return specular + color;\n}\n#elif defined( PRISMGLAZING )\nvec3 Environment_Glazing(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv,\n                         vec3 glazing_f0, vec3 transmissionF, float transmissionAlpha, vec3 glazingAdjustedColor, float glazingIlluminace)\n{\n    float surfaceAlpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 surfaceF = Fresnel_Rough(glazing_f0, NdotV, surfaceAlpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, glazing_f0, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(surfaceAlpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = surfaceF * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 color = 0.5 * (1.0 - transmissionF) * (glazingAdjustedColor - vec3(glazingIlluminace, glazingIlluminace, glazingIlluminace)) * envIrradiance; \n    return specular + color;\n}\n#elif defined( PRISMWOOD )\nvec3 Environment_Wood(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(vec3(0.04), NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(0.04), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * woodDiffuse * envIrradiance;\n    return diffuse + specular;\n}\n#endif\n#endif\n#if defined( PRISMTRANSPARENT )\n#include <prism_transparency>\n#elif defined( PRISMGLAZING )\n#include <prism_glazing>\n#endif\n#ifdef USE_TILING\nvec3 tilingTransform(vec2 uv, mat4 transform)\n{\n\treturn (transform * vec4(uv, 0.0, 1.0)).xyz;\n}\nvec4 tilingMapTest(sampler2D tilingSampler, mat3 transf, vec3 uv, vec4 uv2tile, vec4 tile2uv)\n{\n\tvec2 tileCoord = vec2(dot(uv2tile.xz, uv.xy), dot(uv2tile.yw, uv.xy));\n\tvec2 ijBase = floor(tileCoord);\n    vec2 fracC = fract(tileCoord);\n\tvec2 st = vec2(dot(tile2uv.xz, fracC), dot(tile2uv.yw, fracC));\n\tvec4 tileInfo = vec4(0.0, 0.0, 2.0, 2.0);\n\tvec2 iOffset = float(TILE_RANGE_X_MIN) * tile2uv.xy;\n\tvec2 jBaseOffset = float(TILE_RANGE_Y_MIN) * tile2uv.zw;\n\tfor( int i = TILE_RANGE_X_MIN; i <= TILE_RANGE_X_MAX; i++)\n\t{\n\t\tvec2 jOffset = jBaseOffset;\n\t\tfor( int j = TILE_RANGE_Y_MIN; j <= TILE_RANGE_Y_MAX; j++)\n\t\t{\n\t\t\tvec2 sampleUV = st + iOffset + jOffset;\n\t\t\tjOffset += tile2uv.zw;\n\t\t\tsampleUV = (transf * vec3(sampleUV, 1.0)).xy;\n\t\t\tvec4 tex = texture2D(tilingSampler, sampleUV);\n\t\t\tfloat d = max( min(tex.r, tex.g), min( max(tex.r, tex.g), tex.b));\n            if (d < tileInfo.z) {\n\t\t\t\ttileInfo.xy = vec2(float(i),float(j));\n\t\t\t\ttileInfo.w = tileInfo.z;\n\t\t\t\ttileInfo.z = d;\n\t\t\t} else {\n\t\t\t\ttileInfo.w = min(tileInfo.w, d);\n\t\t\t}\n\t\t}\n\t\tiOffset += tile2uv.xy;\n\t}\n\ttileInfo.zw = tileInfo.zw - 0.5;\n\tfloat w = clamp(tileInfo.z/max(fwidth(tileInfo.z), 0.000001) + 0.5, 0.0, 1.0);\n\tif ( w == 1.0 )\n\t\tdiscard;\n \tif (abs(tileInfo.w)<=abs(tileInfo.z))\n\t\tw = 0.0;\n\ttileInfo.w = 1.0 - w;\n\ttileInfo.xy -= ijBase;\n\treturn tileInfo;\n}\nvec2 tilingSubMaterialRelocate(vec3 uv, vec4 tileInfo, vec4 tile2uv)\n{\n\tvec2 offset = vec2(dot(tile2uv.xz, tileInfo.xy), dot(tile2uv.yw, tileInfo.xy));\n\treturn (uv.xy + offset);\n}\n#ifdef USE_TILING_RANDOM\nvec2 tilingRandom(vec2 uv, vec4 tileInfo, sampler2D randomSampler, mat3 transf, vec2 tileTextureAxisS, vec2 tileTextureAxisT, vec2 tile2TextureOffset)\n{\n    vec2 xti = (vec3(tileInfo.xy, 1.0) * transf).xy;\n    vec4 random = texture2D(randomSampler, xti);\n    vec2 randomOffset = vec2(tileTextureAxisS.x*random.z + tileTextureAxisT.x*random.w,\n        tileTextureAxisS.y*random.z + tileTextureAxisT.y*random.w) + tile2TextureOffset;\n    return uv + randomOffset;\n}\n#endif\nvoid tilingNormalOffset(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (vec3(uv, 1.0) * transform).xy;\n    vec3 distort =  (2.0 * texture2D(bumpTexture, st).xyz - 1.0) - vec3(0.0,0.0,1.0);\n    mat3 mat = mat3(\n        T.x, B.x, N.x,\n        T.y, B.y, N.y,\n        T.z, B.z, N.z\n    );\n    N = normalize(N + (mat*distort));\n}\n#endif\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#include <cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    vec3 N = normalize(vNormal);\n    vec3 Tu = vec3(0.0);\n    vec3 Tv = vec3(0.0);\n#if defined(USE_MAP) || defined(USE_TILING)\n    vec2 uv = vUv;\n#endif\n#ifdef USE_TILING\n    vec3 v_tilingOverallTransf = tilingTransform( vUv, tilingOverallTransform );\n    vec4 v_TilingMap = tilingMapTest( TilingMap, TilingMap_texMatrix, v_tilingOverallTransf, uv2tile, tile2uv );\n    uv = tilingSubMaterialRelocate( v_tilingOverallTransf, v_TilingMap, tile2uv ) + tileAlignOffset;\n#ifdef USE_TILING_NORMAL\n    vec2 uvNorm = uv;\n#endif\n#ifdef USE_TILING_RANDOM\n    uv = tilingRandom( uv, v_TilingMap, TilingRandomMap, TilingRandomMap_texMatrix, tilingRandomAxisS, tilingRandomAxisT, tilingRandomAlignmentOffset );\n#endif\n    uv = tilingTransform( uv, tilingUVTransform ).xy;\n#endif\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0 || defined( PRISMWOODBUMP ) || defined( IMPORTANTSAMPLING )\n#if !defined(USE_MAP) || defined( PRISMWOODBUMP )\n    Tu = normalize(vTangent);\n    Tv = normalize(vBitangent);\n#else\n    vec3 q0 = dFdx( -vViewPosition );\n    vec3 q1 = dFdy( -vViewPosition );\n    vec2 st0 = dFdx( uv );\n    vec2 st1 = dFdy( uv );\n    Tu = normalize(  q0 * st1.t - q1 * st0.t );\n    Tv = normalize( -q0 * st1.s + q1 * st0.s );\n#endif\n#endif\n    vec3 V;\n    if (projectionMatrix[3][3] == 0.0) {\n        V = normalize( vViewPosition );\n    } else {\n        V = vec3(0.0, 0.0, 1.0);\n    }\n    N = faceforward(N, -V, N);\n#if defined(PRISMLAYERED)\n    vec3 N2 = N;\n#endif\n#ifndef FLAT_SHADED\n    vec3 normal = normalize( vNormal );\n#ifdef DOUBLE_SIDED\n    normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#else\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n#endif\n    vec3 geomNormal = normal;\n#if defined( USE_SURFACE_NORMAL_MAP )\n    if (surface_normal_map_bumpmapType == 0)\n        heightMapTransform(surface_normal_map, uv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    else\n        normalMapTransform(surface_normal_map, uv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n#endif\n#if defined( USE_LAYERED_NORMAL_MAP )\n    if (layered_normal_map_bumpmapType == 0)\n        heightMapTransform(layered_normal_map, uv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n    else\n        normalMapTransform(layered_normal_map, uv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n#endif\n#ifdef USE_TILING_NORMAL\n    tilingNormalOffset(TilingNormalMap, uvNorm, TilingNormalMap_texMatrix, Tu, Tv, N);\n#endif\n#if defined( PRISMWOOD )\n#ifdef NO_UVW\n    vec3 p = vec3(0.0);\n#elif defined( USE_WOOD_CURLY_DISTORTION_MAP )\n    vec3 p = DistortCurly(vUvw);\n#else\n    vec3 p = vUvw;\n#endif\n#if !defined( NO_UVW ) && defined( PRISMWOODBUMP )\n    getFinalWoodContext(\n        N, V, Tu, Tv, p,\n        normal, vtNormal, vNormalMatrix\n    );\n#endif\n#endif\n    float NdotV = clamp(dot(N, V), EPSILON, 1.0);\n#if defined(PRISMLAYERED)\n    float N2dotV = clamp(dot(N2, V), EPSILON, 1.0);\n#endif\n    vec3 surfaceAlbedo;\n    #if defined( USE_SURFACE_ALBEDO_MAP )\n        vec2 uv_surface_albedo_map = (surface_albedo_map_texMatrix * vec3(uv, 1.0)).xy;\n        SURFACE_ALBEDO_CLAMP_TEST;\n        surfaceAlbedo = texture2D(surface_albedo_map, uv_surface_albedo_map).xyz;\n        surfaceAlbedo = SRGBToLinear(surfaceAlbedo);\n        if(surface_albedo_map_invert) surfaceAlbedo = vec3(1.0) - surfaceAlbedo;\n    #else\n        surfaceAlbedo = surface_albedo;\n    #endif\n    float surfaceRoughness;\n    #if defined( USE_SURFACE_ROUGHNESS_MAP )\n        vec2 uv_surface_roughness_map = (surface_roughness_map_texMatrix * vec3(uv, 1.0)).xy;\n        SURFACE_ROUGHNESS_CLAMP_TEST;\n        vec3 surfaceRoughness_v3 = texture2D(surface_roughness_map, uv_surface_roughness_map).xyz;\n        if(surface_roughness_map_invert) surfaceRoughness_v3 = vec3(1.0) - surfaceRoughness_v3;\n        surfaceRoughness = average(surfaceRoughness_v3);\n    #else\n        surfaceRoughness = surface_roughness;\n    #endif\n    float surfaceAnisotropy;\n    #if defined( USE_SURFACE_ANISOTROPY_MAP )\n        vec2 uv_surface_anisotropy_map = (surface_anisotropy_map_texMatrix * vec3(uv, 1.0)).xy;\n        SURFACE_ANISOTROPY_CLAMP_TEST;\n        vec3 surfaceAnisotropy_v3 = texture2D(surface_anisotropy_map, uv_surface_anisotropy_map).xyz;\n        if(surface_anisotropy_map_invert) surfaceAnisotropy_v3 = vec3(1.0) - surfaceAnisotropy_v3;\n        surfaceAnisotropy = average(surfaceAnisotropy_v3);\n    #else\n        surfaceAnisotropy = surface_anisotropy;\n    #endif\n    float surfaceRotation;\n    #if defined( USE_SURFACE_ROTATION_MAP )\n        vec2 uv_surface_rotation_map = (surface_rotation_map_texMatrix * vec3(uv, 1.0)).xy;\n        SURFACE_ROTATION_CLAMP_TEST;\n        vec3 surfaceRotation_v3 = texture2D(surface_rotation_map, uv_surface_rotation_map).xyz;\n        if(surface_rotation_map_invert) surfaceRotation_v3 = vec3(1.0) - surfaceRotation_v3;\n        surfaceRotation = average(surfaceRotation_v3);\n    #else\n        surfaceRotation = surface_rotation;\n    #endif\n    #if defined(PRISMOPAQUE)\n        float opaqueF0;\n        #if defined( USE_OPAQUE_F0_MAP )\n            vec2 uv_opaque_f0_map = (opaque_f0_map_texMatrix * vec3(uv, 1.0)).xy;\n            OPAQUE_F0_CLAMP_TEST;\n            vec3 opaqueF0_v3 = texture2D(opaque_f0_map, uv_opaque_f0_map).xyz;\n            if(opaque_f0_map_invert) opaqueF0_v3 = vec3(1.0) - opaqueF0_v3;\n            opaqueF0 = average(opaqueF0_v3);\n        #else\n            opaqueF0 = opaque_f0;\n        #endif\n        vec3 opaqueAlbedo;\n        #if defined( USE_OPAQUE_ALBEDO_MAP )\n            vec2 uv_opaque_albedo_map = (opaque_albedo_map_texMatrix * vec3(uv, 1.0)).xy;\n            OPAQUE_ALBEDO_CLAMP_TEST;\n            opaqueAlbedo = texture2D(opaque_albedo_map, uv_opaque_albedo_map).xyz;\n            opaqueAlbedo = SRGBToLinear(opaqueAlbedo);\n            if(opaque_albedo_map_invert) opaqueAlbedo = vec3(1.0) - opaqueAlbedo;\n        #else\n            opaqueAlbedo = opaque_albedo;\n        #endif\n        #elif defined(PRISMMETAL)\n        vec3 metalF0;\n        #if defined( USE_METAL_F0_MAP )\n            vec2 uv_metal_f0_map = (metal_f0_map_texMatrix * vec3(uv, 1.0)).xy;\n            METAL_F0_CLAMP_TEST;\n            metalF0 = texture2D(metal_f0_map, uv_metal_f0_map).xyz;\n            metalF0 = SRGBToLinear(metalF0);\n            if(metal_f0_map_invert) metalF0 = vec3(1.0) - metalF0;\n        #else\n            metalF0 = metal_f0;\n        #endif\n        #elif defined(PRISMLAYERED)\n        float layeredF0;\n        #if defined( USE_LAYERED_F0_MAP )\n            vec2 uv_layered_f0_map = (layered_f0_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_F0_CLAMP_TEST;\n            vec3 layeredF0_v3 = texture2D(layered_f0_map, uv_layered_f0_map).xyz;\n            if(layered_f0_map_invert) layeredF0_v3 = vec3(1.0) - layeredF0_v3;\n            layeredF0 = average(layeredF0_v3);\n        #else\n            layeredF0 = layered_f0;\n        #endif\n        vec3 layeredDiffuse;\n        #if defined( USE_LAYERED_DIFFUSE_MAP )\n            vec2 uv_layered_diffuse_map = (layered_diffuse_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_DIFFUSE_CLAMP_TEST;\n            layeredDiffuse = texture2D(layered_diffuse_map, uv_layered_diffuse_map).xyz;\n            layeredDiffuse = SRGBToLinear(layeredDiffuse);\n            if(layered_diffuse_map_invert) layeredDiffuse = vec3(1.0) - layeredDiffuse;\n        #else\n            layeredDiffuse = layered_diffuse;\n        #endif\n        float layeredRoughness;\n        #if defined( USE_LAYERED_ROUGHNESS_MAP )\n            vec2 uv_layered_roughness_map = (layered_roughness_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_ROUGHNESS_CLAMP_TEST;\n            vec3 layeredRoughness_v3 = texture2D(layered_roughness_map, uv_layered_roughness_map).xyz;\n            if(layered_roughness_map_invert) layeredRoughness_v3 = vec3(1.0) - layeredRoughness_v3;\n            layeredRoughness = average(layeredRoughness_v3);\n        #else\n            layeredRoughness = layered_roughness;\n        #endif\n        float layeredAnisotropy;\n        #if defined( USE_LAYERED_ANISOTROPY_MAP )\n            vec2 uv_layered_anisotropy_map = (layered_anisotropy_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_ANISOTROPY_CLAMP_TEST;\n            vec3 layeredAnisotropy_v3 = texture2D(layered_anisotropy_map, uv_layered_anisotropy_map).xyz;\n            if(layered_anisotropy_map_invert) layeredAnisotropy_v3 = vec3(1.0) - layeredAnisotropy_v3;\n            layeredAnisotropy = average(layeredAnisotropy_v3);\n        #else\n            layeredAnisotropy = layered_anisotropy;\n        #endif\n        float layeredRotation;\n        #if defined( USE_LAYERED_ROTATION_MAP )\n            vec2 uv_layered_rotation_map = (layered_rotation_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_ROTATION_CLAMP_TEST;\n            vec3 layeredRotation_v3 = texture2D(layered_rotation_map, uv_layered_rotation_map).xyz;\n            if(layered_rotation_map_invert) layeredRotation_v3 = vec3(1.0) - layeredRotation_v3;\n            layeredRotation = average(layeredRotation_v3);\n        #else\n            layeredRotation = layered_rotation;\n        #endif\n        vec3 bottom_f0;\n        #if defined( USE_LAYERED_BOTTOM_F0_MAP )\n            vec2 uv_layered_bottom_f0_map = (layered_bottom_f0_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_BOTTOM_F0_CLAMP_TEST;\n            bottom_f0 = texture2D(layered_bottom_f0_map, uv_layered_bottom_f0_map).xyz;\n            bottom_f0 = SRGBToLinear(bottom_f0);\n            if(layered_bottom_f0_map_invert) bottom_f0 = vec3(1.0) - bottom_f0;\n        #else\n            bottom_f0 = layered_bottom_f0;\n        #endif\n        float layeredFraction;\n        #if defined( USE_LAYERED_FRACTION_MAP )\n            vec2 uv_layered_fraction_map = (layered_fraction_map_texMatrix * vec3(uv, 1.0)).xy;\n            LAYERED_FRACTION_CLAMP_TEST;\n            vec3 layeredFraction_v3 = texture2D(layered_fraction_map, uv_layered_fraction_map).xyz;\n            if(layered_fraction_map_invert) layeredFraction_v3 = vec3(1.0) - layeredFraction_v3;\n            layeredFraction = average(layeredFraction_v3);\n        #else\n            layeredFraction = layered_fraction;\n        #endif\n        #elif defined( PRISMGLAZING )\n        vec3 glazingTransmissionColor;\n        #if defined( USE_GLAZING_TRANSMISSION_COLOR_MAP )\n            vec2 uv_glazing_transmission_color_map = (glazing_transmission_color_map_texMatrix * vec3(uv, 1.0)).xy;\n            GLAZING_TRANSMISSION_COLOR_CLAMP_TEST;\n            glazingTransmissionColor = texture2D(glazing_transmission_color_map, uv_glazing_transmission_color_map).xyz;\n            glazingTransmissionColor = SRGBToLinear(glazingTransmissionColor);\n            if(glazing_transmission_color_map_invert) glazingTransmissionColor = vec3(1.0) - glazingTransmissionColor;\n        #else\n            glazingTransmissionColor = glazing_transmission_color;\n        #endif\n        vec3 glazingF0;\n        #if defined( USE_GLAZING_F0_MAP )\n            vec2 uv_glazing_f0_map = (glazing_f0_map_texMatrix * vec3(uv, 1.0)).xy;\n            GLAZING_F0_CLAMP_TEST;\n            glazingF0 = texture2D(glazing_f0_map, uv_glazing_f0_map).xyz;\n            glazingF0 = SRGBToLinear(glazingF0);\n            if(glazing_f0_map_invert) glazingF0 = vec3(1.0) - glazingF0;\n        #else\n            glazingF0 = glazing_f0;\n        #endif\n        float glazingTransmissionRoughness;\n        #if defined( USE_GLAZING_TRANSMISSION_ROUGHNESS_MAP )\n            vec2 uv_glazing_transmission_roughness_map = (glazing_transmission_roughness_map_texMatrix * vec3(uv, 1.0)).xy;\n            GLAZING_TRANSMISSION_ROUGHNESS_CLAMP_TEST;\n            vec3 glazingTransmissionRoughness_v3 = texture2D(glazing_transmission_roughness_map, uv_glazing_transmission_roughness_map).xyz;\n            if(glazing_transmission_roughness_map_invert) glazingTransmissionRoughness_v3 = vec3(1.0) - glazingTransmissionRoughness_v3;\n            glazingTransmissionRoughness = average(glazingTransmissionRoughness_v3);\n        #else\n            glazingTransmissionRoughness = glazing_transmission_roughness;\n        #endif\n    vec3 glazingAdjustedColor = TransmitAdjust(glazingTransmissionColor, glazingF0);\n    float glazingIlluminace = ColorToIlluminance(glazingAdjustedColor);\n    float transmissionAlpha = RoughnessToAlpha(glazingTransmissionRoughness, 0.0).x;\n    vec3 transmissionF = Fresnel_Rough(glazingF0, NdotV, transmissionAlpha);\n#elif defined(PRISMWOOD)\n    vec3 woodDiffuse = NoiseWood(p, surfaceRoughness);\n#endif\n    vec3 outRadianceLight = vec3(0.0);\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\n    vec3 lightDirection[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n    vec3 lightColor[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n#if MAX_DIR_LIGHTS > 0\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n        vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n        lightDirection[i] = normalize( lDirection.xyz );\n        lightColor[i] = SRGBToLinear(directionalLightColor[ i ]);\n    }\n#endif\n#if MAX_POINT_LIGHTS > 0\n    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        lightDirection[MAX_DIR_LIGHTS + i] = normalize( lVector );\n        float lDistance = 1.0;\n        if ( pointLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n        lightColor[MAX_DIR_LIGHTS + i] = SRGBToLinear(pointLightColor[ i ]) * lDistance;\n    }\n#endif\n#if MAX_SPOT_LIGHTS > 0\n    for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        lightDirection[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = normalize( lVector );\n        float lDistance = 1.0;\n        if ( spotLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n        if ( spotEffect > spotLightAngleCos[ i ] )\n            spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n        lightColor[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = SRGBToLinear(spotLightColor[ i ]) * lDistance * spotEffect;\n    }\n#endif\n    for( int i = 0; i < MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS; i ++ ) {\n        vec3 L = lightDirection[i];\n        float NdotL = max(EPSILON, dot(N, L));\n        vec3 H = normalize(L + V);\n        float NdotH = dot(N, H);\n        float VdotH = dot(V, H);\n        float Hu = dot(H, Tu);\n        float Hv = dot(H, Tv);\n        vec3 Hlocal = vec3(Hu, Hv, NdotH);\n#if defined(PRISMLAYERED)\n        float N2dotL = dot(N2, L);\n        float N2dotH = dot(N2, H);\n        vec3 Hlocal2 = vec3(Hu, Hv, N2dotH);\n#endif\n        vec3 brdf = lightColor[i] *\n#if defined(PRISMOPAQUE)\n            BRDF_Opaque(Hlocal, NdotL, NdotH, NdotV, VdotH,\n                    surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                    opaqueF0, opaqueAlbedo);\n#elif defined(PRISMMETAL)\n            BRDF_Metal(Hlocal, NdotL, NdotH, NdotV, VdotH,\n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                metalF0);\n#elif defined(PRISMLAYERED)\n            BRDF_Layered(Hlocal, NdotL, NdotH, NdotV, VdotH, Hlocal2, N2dotL, N2dotH, N2dotV,\n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n                layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n            BRDF_Transparent(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation);\n#elif defined(PRISMGLAZING)\n            BRDF_Glazing(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                         glazingF0, glazingTransmissionColor, glazingIlluminace);\n#elif defined(PRISMWOOD)\n            BRDF_Wood(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, woodDiffuse);\n#endif\n        outRadianceLight += max(vec3(0.0), brdf);\n    }\n#endif\n    vec3 outRadianceEnv = vec3(0.0);\n#if defined( USE_ENVMAP )\n    outRadianceEnv =\n#if defined(PRISMOPAQUE)\n        Environment_Opaque(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n                opaqueF0, opaqueAlbedo, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMMETAL)\n        Environment_Metal(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, metalF0, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMLAYERED)\n        Environment_Layered(N, V, clamp(NdotV, 0.0, 1.0), N2, clamp(N2dotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n            layeredF0, surfaceAnisotropy, surfaceRotation, Tu, Tv, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n            layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n        Environment_Transparent(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMGLAZING)\n        Environment_Glazing(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, Tu, Tv,\n            glazingF0, transmissionF, transmissionAlpha, glazingAdjustedColor, glazingIlluminace);\n#elif defined(PRISMWOOD)\n        Environment_Wood(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, woodDiffuse, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#endif\n#endif\n#if defined(PRISMOPAQUE)\n    vec3 luminanceModifier;\n    #if defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )\n        vec2 uv_opaque_luminance_modifier_map = (opaque_luminance_modifier_map_texMatrix * vec3(uv, 1.0)).xy;\n        OPAQUE_LUMINANCE_MODIFIER_CLAMP_TEST;\n        luminanceModifier = texture2D(opaque_luminance_modifier_map, uv_opaque_luminance_modifier_map).xyz;\n        luminanceModifier = SRGBToLinear(luminanceModifier);\n        if(opaque_luminance_modifier_map_invert) luminanceModifier = vec3(1.0) - luminanceModifier;\n    #else\n        luminanceModifier = opaque_luminance_modifier;\n    #endif\n    outRadianceEnv += luminanceModifier * opaque_luminance;\n#endif\n    float surface_cutout = 1.0;\n    #if defined( USE_SURFACE_CUTOUT_MAP )\n        vec2 uv_surface_cutout_map = (surface_cutout_map_texMatrix * vec3(uv, 1.0)).xy;\n        SURFACE_CUTOUT_CLAMP_TEST;\n        vec3 surface_cutout_v3 = texture2D(surface_cutout_map, uv_surface_cutout_map).xyz;\n        if(surface_cutout_map_invert) surface_cutout_v3 = vec3(1.0) - surface_cutout_v3;\n        surface_cutout = average(surface_cutout_v3);\n    #else\n        surface_cutout = surface_cutout;\n    #endif\n#if defined( USE_SURFACE_CUTOUT_MAP )\n    if(surface_cutout < 0.01) discard;\n#endif\n    gl_FragColor = vec4( outRadianceLight + outRadianceEnv, opacity*surface_cutout );\n#if TONEMAP_OUTPUT == 1\n    gl_FragColor.xyz = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.xyz);\n#elif TONEMAP_OUTPUT == 2\n    gl_FragColor.xyz = toneMapCanonFilmic_WithGamma(exposureBias * gl_FragColor.xyz);\n#endif\n#ifdef USE_FOG\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif\n#if defined(PRISMTRANSPARENT)\n    applyPrismTransparency(gl_FragColor, transparent_color, transparent_ior);\n    gl_FragColor.a *= surface_cutout;\n#ifdef USE_TILING\n    gl_FragColor.a *= v_TilingMap.a;\n#endif\n#elif defined( PRISMGLAZING )\n    applyPrismGlazingOpacity(gl_FragColor, transmissionF, transmissionAlpha, NdotV, glazingIlluminace);\n#ifdef USE_TILING\n    gl_FragColor.a *= v_TilingMap.a;\n#endif\n#endif\n#include <theming_frag>\n#include <final_frag>\n}\n"},74630:e=>{e.exports="varying vec3 vViewPosition;\nvarying vec3 vNormal;\n#if defined(PRISMWOOD) && !defined(NO_UVW)\nvarying vec3 vUvw;\n#if defined(PRISMWOODBUMP)\nvarying vec3 vtNormal;\nvarying mat3 mNormalMatrix;\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#if defined( USE_SURFACE_ALBEDO_MAP ) || defined( USE_SURFACE_ROUGHNESS_MAP ) || defined( USE_SURFACE_CUTOUT_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_OPAQUE_ALBEDO_MAP ) || defined( USE_OPAQUE_F0_MAP ) || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP ) || defined( USE_LAYERED_BOTTOM_F0_MAP ) || defined( USE_LAYERED_F0_MAP ) || defined( USE_LAYERED_DIFFUSE_MAP ) || defined( USE_LAYERED_FRACTION_MAP ) || defined( USE_LAYERED_ROUGHNESS_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_METAL_F0_MAP ) || defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )\n    #define USE_MAP\n#endif\n#if defined(USE_MAP) || defined(USE_TILING)\nvarying vec2 vUv;\n#endif\n#ifdef MRT_NORMALS\nvarying float depth;\n#endif\n#include <pack_normals>\n#include <instancing_decl_vert>\n#include <id_decl_vert>\n#include <shadowmap_decl_vert>\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined( PRISMWOODBUMP )\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\n#endif\nvoid main() {\n#if defined(USE_MAP) || defined(USE_TILING)\n    vUv = uv;\n#endif\n#ifdef UNPACK_NORMALS\n    vec3 objectNormal = decodeNormal(normal);\n#else\n    vec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n    objectNormal = getInstanceNormal(objectNormal);\n    vec3 instPos = getInstancePos(position);\n#if defined(PRISMWOOD) && !defined(NO_UVW)\n#if defined(PRISMWOODBUMP)\n    vUvw = instPos;\n    vtNormal = normalize(objectNormal);\n    mNormalMatrix = normalMatrix;\n#else\n    vUvw = uvw;\n#endif\n#endif\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    vNormal = normalize( transformedNormal );\n    vec4 mvPosition = modelViewMatrix * vec4( instPos, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( instPos, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined ( PRISMWOODBUMP )\n    vec3 Tu, Tv;\n#if defined(PRISMWOODBUMP)\n    ComputeTangents(vtNormal, Tu, Tv);\n#else\n    ComputeTangents(vNormal, Tu, Tv);\n#endif\n    vTangent = Tu;\n    vBitangent = Tv;\n#endif\n#ifdef MRT_NORMALS\n    depth = mvPosition.z;\n#endif\n#include <id_vert>\n#include <shadowmap_vert>\n}\n"}},n={};function o(a){var r=n[a];if(void 0!==r)return r.exports;var t=n[a]={exports:{}};return e[a](t,t.exports,o),t.exports}o.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return o.d(n,{a:n}),n},o.d=(e,n)=>{for(var a in n)o.o(n,a)&&!o.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},o.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var a={};(()=>{"use strict";o.r(a);var e={};o.r(e),o.d(e,{PrismShader:()=>c,clonePrismMaterial:()=>m,createPrismMaterial:()=>p});var n={};o.r(n),o.d(n,{GetPrismMapChunk:()=>S,PrismMaps:()=>N,PrismMaterial:()=>H});var r={};o.r(r),o.d(r,{convertPrismMaterial:()=>ie,convertPrismTexture:()=>he,disposePrismWoodTextures:()=>re,materialTilingPattern:()=>se,swapPrismWoodTextures:()=>ae});var t=o(74630),i=o.n(t),l=o(43214),s=o.n(l),_=Autodesk.Viewing.Private,f=_.ShaderChunks,d=_.PrismUtil.GetPrismMapUniforms;function u(e){var n=e+"_texMatrix",o=e+"_bumpScale",a=e+"_bumpmapType",r={};return r[e]={type:"t",value:null},r[n]={type:"m3",value:new THREE.Matrix3},r[o]={type:"v2",value:new THREE.Vector2(1,1)},r[a]={type:"i",value:0},r}var c={uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.lights,THREE.UniformsLib.fog,f.CutPlanesUniforms,f.IdUniforms,f.ThemingUniform,f.ShadowMapUniforms,d("surface_albedo_map"),d("surface_roughness_map"),d("surface_cutout_map"),d("surface_anisotropy_map"),d("surface_rotation_map"),d("opaque_albedo_map"),d("opaque_f0_map"),d("opaque_luminance_modifier_map"),d("layered_bottom_f0_map"),d("layered_f0_map"),d("layered_diffuse_map"),d("layered_fraction_map"),d("layered_roughness_map"),d("layered_anisotropy_map"),d("layered_rotation_map"),d("metal_f0_map"),d("wood_curly_distortion_map"),d("glazing_f0_map"),d("glazing_transmission_color_map"),d("glazing_transmission_roughness_map"),u("surface_normal_map"),u("layered_normal_map"),d("TilingMap"),d("TilingNormalMap"),d("TilingRandomMap"),{surface_albedo:{type:"c",value:new THREE.Color(1118481)},surface_roughness:{type:"f",value:1},surface_anisotropy:{type:"f",value:1},surface_rotation:{type:"f",value:1},opaque_albedo:{type:"c",value:new THREE.Color(1118481)},opaque_f0:{type:"f",value:1},opaque_luminance_modifier:{type:"c",value:new THREE.Color(1118481)},opaque_luminance:{type:"f",value:1},metal_f0:{type:"c",value:new THREE.Color(1118481)},layered_f0:{type:"f",value:1},layered_diffuse:{type:"c",value:new THREE.Color(0)},layered_fraction:{type:"f",value:1},layered_bottom_f0:{type:"c",value:new THREE.Color(1118481)},layered_roughness:{type:"f",value:1},layered_anisotropy:{type:"f",value:1},layered_rotation:{type:"f",value:1},transparent_ior:{type:"f",value:2},transparent_color:{type:"c",value:new THREE.Color(1118481)},transparent_distance:{type:"f",value:1},glazing_f0:{type:"c",value:new THREE.Color(16777215)},glazing_transmission_roughness:{type:"f",value:0},glazing_transmission_color:{type:"c",value:new THREE.Color(16777215)},wood_fiber_cosine_enable:{type:"i",value:1},wood_fiber_cosine_bands:{type:"i",value:2},wood_fiber_cosine_weights:{type:"v4",value:new THREE.Vector4(2.5,.5,1,1)},wood_fiber_cosine_frequencies:{type:"v4",value:new THREE.Vector4(15,4,1,1)},wood_fiber_perlin_enable:{type:"i",value:1},wood_fiber_perlin_bands:{type:"i",value:3},wood_fiber_perlin_weights:{type:"v4",value:new THREE.Vector4(3,1,.2,1)},wood_fiber_perlin_frequencies:{type:"v4",value:new THREE.Vector4(40,20,3.5,1)},wood_fiber_perlin_scale_z:{type:"f",value:.3},wood_growth_perlin_enable:{type:"i",value:1},wood_growth_perlin_bands:{type:"i",value:3},wood_growth_perlin_weights:{type:"v4",value:new THREE.Vector4(1,2,1,1)},wood_growth_perlin_frequencies:{type:"v4",value:new THREE.Vector4(1,5,13,1)},wood_latewood_ratio:{type:"f",value:.238},wood_earlywood_sharpness:{type:"f",value:.395},wood_latewood_sharpness:{type:"f",value:.109},wood_ring_thickness:{type:"f",value:.75},wood_earlycolor_perlin_enable:{type:"i",value:1},wood_earlycolor_perlin_bands:{type:"i",value:2},wood_earlycolor_perlin_weights:{type:"v4",value:new THREE.Vector4(.3,.5,.15,1)},wood_earlycolor_perlin_frequencies:{type:"v4",value:new THREE.Vector4(8,3,.35,1)},wood_early_color:{type:"c",value:new THREE.Color(.286,.157,.076)},wood_use_manual_late_color:{type:"i",value:0},wood_manual_late_color:{type:"c",value:new THREE.Color(.62,.35,.127)},wood_latecolor_perlin_enable:{type:"i",value:1},wood_latecolor_perlin_bands:{type:"i",value:1},wood_latecolor_perlin_weights:{type:"v4",value:new THREE.Vector4(.75,.55,1,1)},wood_latecolor_perlin_frequencies:{type:"v4",value:new THREE.Vector4(4.5,.05,1,1)},wood_late_color_power:{type:"f",value:1.25},wood_diffuse_perlin_enable:{type:"i",value:1},wood_diffuse_perlin_bands:{type:"i",value:3},wood_diffuse_perlin_weights:{type:"v4",value:new THREE.Vector4(.15,.2,.05,1)},wood_diffuse_perlin_frequencies:{type:"v4",value:new THREE.Vector4(.05,.1,3,1)},wood_diffuse_perlin_scale_z:{type:"f",value:.2},wood_use_pores:{type:"i",value:1},wood_pore_type:{type:"i",value:0},wood_pore_radius:{type:"f",value:.04},wood_pore_cell_dim:{type:"f",value:.15},wood_pore_color_power:{type:"f",value:1.45},wood_pore_depth:{type:"f",value:.02},wood_use_rays:{type:"i",value:1},wood_ray_color_power:{type:"f",value:1.1},wood_ray_seg_length_z:{type:"f",value:5},wood_ray_num_slices:{type:"f",value:160},wood_ray_ellipse_z2x:{type:"f",value:10},wood_ray_ellipse_radius_x:{type:"f",value:.2},wood_use_latewood_bump:{type:"i",value:1},wood_latewood_bump_depth:{type:"f",value:.01},wood_use_groove_roughness:{type:"i",value:1},wood_groove_roughness:{type:"f",value:.85},wood_diffuse_lobe_weight:{type:"f",value:.9},wood_curly_distortion_enable:{type:"i",value:0},wood_curly_distortion_scale:{type:"f",value:.25},wood_ring_fraction:{type:"v4",value:new THREE.Vector4(0,0,0,0)},wood_fall_rise:{type:"v2",value:new THREE.Vector2(0,0)},permutationMap:{type:"t",value:null},gradientMap:{type:"t",value:null},perm2DMap:{type:"t",value:null},permGradMap:{type:"t",value:null},importantSamplingRandomMap:{type:"t",value:null},importantSamplingSolidAngleMap:{type:"t",value:null},irradianceMap:{type:"t",value:null},envMap:{type:"t",value:null},exposureBias:{type:"f",value:1},envMapExposure:{type:"f",value:1},envRotationSin:{type:"f",value:0},envRotationCos:{type:"f",value:1},envExponentMin:{type:"f",value:1},envExponentMax:{type:"f",value:512},envExponentCount:{type:"f",value:10},tilingOverallTransform:{type:"m4",value:new THREE.Matrix4},uv2tile:{type:"v4",value:new THREE.Vector4(1,0,0,1)},tile2uv:{type:"v4",value:new THREE.Vector4(1,0,0,1)},tileAlignOffset:{type:"v2",value:new THREE.Vector2(0,0)},tilingUVTransform:{type:"m4",value:new THREE.Matrix4},tilingRandomAxisS:{type:"v2",value:new THREE.Vector2(0,0)},tilingRandomAxisT:{type:"v2",value:new THREE.Vector2(0,0)},tilingRandomAlignmentOffset:{type:"v2",value:new THREE.Vector2(0,0)}}]),vertexShader:i(),fragmentShader:s()};THREE.ShaderLib.prism=c;var p=function(){return console.warn("createPrismMaterial has been deprecated. Use new PrismMaterial instead"),new H},m=function(e){return console.warn("clonePrismMaterial has been deprecated. Use new PrismMaterial.clone instead"),e.clone()};function v(e){return v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},v(e)}function g(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,a)}return o}function y(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?g(Object(o),!0).forEach((function(n){E(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):g(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function E(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function h(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function T(e,n){for(var o=0;o<n.length;o++){var a=n[o];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function R(e,n){return R=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e},R(e,n)}function w(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var o,a=x(e);if(n){var r=x(this).constructor;o=Reflect.construct(a,arguments,r)}else o=a.apply(this,arguments);return M(this,o)}}function M(e,n){return!n||"object"!==v(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function x(e){return x=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},x(e)}function A(e,n,o){e[o].value=n[o],null!=n[o]&&(e[o+"_texMatrix"].value=n[o].matrix,e[o+"_invert"].value=n[o].invert)}function b(e,n,o){e[o].value=n[o],null!=n[o]&&(e[o+"_texMatrix"].value=n[o].matrix,e[o+"_bumpScale"].value=n[o].bumpScale,e[o+"_bumpmapType"].value=n[o].bumpmapType)}var S=function(e,n,o){var a="uv_"+e+"_map",r="";return n&&o?r="if ("+a+".x < 0.0 || "+a+".x > 1.0 || "+a+".y < 0.0 || "+a+".y > 1.0) { discard; }":n?r="if ("+a+".x < 0.0 || "+a+".x > 1.0) { discard; }":o&&(r="if ("+a+".y < 0.0 || "+a+".y > 1.0) { discard; }"),"#define "+e.toUpperCase()+"_CLAMP_TEST "+r},N=["opaque_luminance_modifier","surface_albedo","surface_roughness","surface_anisotropy","surface_rotation","opaque_f0","opaque_albedo","metal_f0","layered_f0","layered_diffuse","layered_roughness","layered_anisotropy","layered_rotation","layered_bottom_f0","layered_fraction","surface_cutout","glazing_transmission_color","glazing_f0","glazing_transmission_roughness","wood_curly_distortion"],P=function(e){for(var n="\n",o=0;o<N.length;o++){var a=e[N[o]];a&&(n+=S(N[o],a.S,a.T)+"\n")}return n},H=function(e){!function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&R(e,n)}(t,THREE.ShaderMaterial);var n,o,a,r=w(t);function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};h(this,t);var o={vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,uniforms:THREE.UniformsUtils.clone(c.uniforms)};return(e=r.call(this,y(y({},n),o))).defaultAttributeValues.uvw=[0,0,0],e.enable3DWoodBump=!1,e.enableImportantSampling=!1,e.mapList={},e.lights=!0,e}return n=t,(o=[{key:"clone",value:function(){var e=new t;return e.copy(this),e}},{key:"copy",value:function(e){switch(this.name=e.name,this.side=e.side,this.opacity=e.opacity,this.transparent=e.transparent,this.blending=e.blending,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.alphaTest=e.alphaTest,this.overdraw=e.overdraw,this.visible=e.visible,this.mapList=e.mapList,this.prismType=e.prismType,this.surface_albedo=e.surface_albedo,void 0!==e.surface_albedo_map&&(this.surface_albedo_map=e.surface_albedo_map),this.surface_roughness=e.surface_roughness,void 0!==e.surface_roughness_map&&(this.surface_roughness_map=e.surface_roughness_map),this.surface_anisotropy=e.surface_anisotropy,void 0!==e.surface_anisotropy_map&&(this.surface_anisotropy_map=e.surface_anisotropy_map),this.surface_rotation=e.surface_rotation,void 0!==e.surface_rotation_map&&(this.surface_rotation_map=e.surface_rotation_map),void 0!==e.surface_cutout_map&&(this.surface_cutout_map=e.surface_cutout_map),void 0!==e.surface_normal_map&&(this.surface_normal_map=e.surface_normal_map),this.uniforms.importantSamplingRandomMap.value=e.uniforms.importantSamplingRandomMap.value,this.uniforms.importantSamplingSolidAngleMap.value=e.uniforms.importantSamplingSolidAngleMap.value,this.prismType){case"PrismOpaque":this.opaque_albedo=(new THREE.Color).copy(e.opaque_albedo),this.opaque_luminance_modifier=(new THREE.Color).copy(e.opaque_luminance_modifier),this.opaque_f0=e.opaque_f0,this.opaque_luminance=e.opaque_luminance,void 0!==e.opaque_albedo_map&&(this.opaque_albedo_map=e.opaque_albedo_map),void 0!==e.opaque_luminance_modifier_map&&(this.opaque_luminance_modifier_map=e.opaque_luminance_modifier_map),void 0!==e.opaque_f0_map&&(this.opaque_f0_map=e.opaque_f0_map);break;case"PrismMetal":this.metal_f0=(new THREE.Color).copy(e.metal_f0),void 0!==e.metal_f0_map&&(this.metal_f0_map=e.metal_f0_map);break;case"PrismLayered":this.layered_f0=e.layered_f0,this.layered_diffuse=(new THREE.Color).copy(e.layered_diffuse),this.layered_fraction=e.layered_fraction,this.layered_bottom_f0=(new THREE.Color).copy(e.layered_bottom_f0),this.layered_roughness=e.layered_roughness,this.layered_anisotropy=e.layered_anisotropy,this.layered_rotation=e.layered_rotation,void 0!==e.layered_bottom_f0_map&&(this.layered_bottom_f0_map=e.layered_bottom_f0_map),void 0!==e.layered_f0_map&&(this.layered_f0_map=e.layered_f0_map),void 0!==e.layered_diffuse_map&&(this.layered_diffuse_map=e.layered_diffuse_map),void 0!==e.layered_fraction_map&&(this.layered_fraction_map=e.layered_fraction_map),void 0!==e.layered_rotationlayered_roughness_map&&(this.layered_rotationlayered_roughness_map=e.layered_rotationlayered_roughness_map),void 0!==e.layered_anisotropy_map&&(this.layered_anisotropy_map=e.layered_anisotropy_map),void 0!==e.layered_rotation_map&&(this.layered_rotation_map=e.layered_rotation_map),void 0!==e.layered_normal_map&&(this.layered_normal_map=e.layered_normal_map);break;case"PrismTransparent":this.transparent_color=(new THREE.Color).copy(e.transparent_color),this.transparent_distance=e.transparent_distance,this.transparent_ior=e.transparent_ior,this.transparent=e.transparent,this.twoPassTransparency=e.twoPassTransparency;break;case"PrismGlazing":this.glazing_f0=(new THREE.Color).copy(e.glazing_f0),this.glazing_transmission_color=(new THREE.Color).copy(e.glazing_transmission_color),this.glazing_transmission_roughness=e.glazing_transmission_roughness,void 0!==e.glazing_f0_map&&(this.glazing_f0_map=e.glazing_f0_map),void 0!==e.glazing_transmission_color_map&&(this.glazing_transmission_color_map=e.glazing_transmission_color_map),void 0!==e.glazing_transmission_roughness_map&&(this.glazing_transmission_roughness_map=e.glazing_transmission_roughness_map);break;case"PrismWood":this.wood_fiber_cosine_enable=e.wood_fiber_cosine_enable,this.wood_fiber_cosine_bands=e.wood_fiber_cosine_bands,this.wood_fiber_cosine_weights=(new THREE.Vector4).copy(e.wood_fiber_cosine_weights),this.wood_fiber_cosine_frequencies=(new THREE.Vector4).copy(e.wood_fiber_cosine_frequencies),this.wood_fiber_perlin_enable=e.wood_fiber_perlin_enable,this.wood_fiber_perlin_bands=e.wood_fiber_perlin_bands,this.wood_fiber_perlin_weights=(new THREE.Vector4).copy(e.wood_fiber_perlin_weights),this.wood_fiber_perlin_frequencies=(new THREE.Vector4).copy(e.wood_fiber_perlin_frequencies),this.wood_fiber_perlin_scale_z=e.wood_fiber_perlin_scale_z,this.wood_growth_perlin_enable=e.wood_growth_perlin_enable,this.wood_growth_perlin_bands=e.wood_growth_perlin_bands,this.wood_growth_perlin_weights=(new THREE.Vector4).copy(e.wood_growth_perlin_weights),this.wood_growth_perlin_frequencies=(new THREE.Vector4).copy(e.wood_growth_perlin_frequencies),this.wood_latewood_ratio=e.wood_latewood_ratio,this.wood_earlywood_sharpness=e.wood_earlywood_sharpness,this.wood_latewood_sharpness=e.wood_latewood_sharpness,this.wood_ring_thickness=e.wood_ring_thickness,this.wood_earlycolor_perlin_enable=e.wood_earlycolor_perlin_enable,this.wood_earlycolor_perlin_bands=e.wood_earlycolor_perlin_bands,this.wood_earlycolor_perlin_weights=(new THREE.Vector4).copy(e.wood_earlycolor_perlin_weights),this.wood_earlycolor_perlin_frequencies=(new THREE.Vector4).copy(e.wood_earlycolor_perlin_frequencies),this.wood_early_color=(new THREE.Color).copy(e.wood_early_color),this.wood_use_manual_late_color=e.wood_use_manual_late_color,this.wood_manual_late_color=(new THREE.Color).copy(e.wood_manual_late_color),this.wood_latecolor_perlin_enable=e.wood_latecolor_perlin_enable,this.wood_latecolor_perlin_bands=e.wood_latecolor_perlin_bands,this.wood_latecolor_perlin_weights=(new THREE.Vector4).copy(e.wood_latecolor_perlin_weights),this.wood_latecolor_perlin_frequencies=(new THREE.Vector4).copy(e.wood_latecolor_perlin_frequencies),this.wood_late_color_power=e.wood_late_color_power,this.wood_diffuse_perlin_enable=e.wood_diffuse_perlin_enable,this.wood_diffuse_perlin_bands=e.wood_diffuse_perlin_bands,this.wood_diffuse_perlin_weights=(new THREE.Vector4).copy(e.wood_diffuse_perlin_weights),this.wood_diffuse_perlin_frequencies=(new THREE.Vector4).copy(e.wood_diffuse_perlin_frequencies),this.wood_diffuse_perlin_scale_z=e.wood_diffuse_perlin_scale_z,this.wood_use_pores=e.wood_use_pores,this.wood_pore_type=e.wood_pore_type,this.wood_pore_radius=e.wood_pore_radius,this.wood_pore_cell_dim=e.wood_pore_cell_dim,this.wood_pore_color_power=e.wood_pore_color_power,this.wood_pore_depth=e.wood_pore_depth,this.wood_use_rays=e.wood_use_rays,this.wood_ray_color_power=e.wood_ray_color_power,this.wood_ray_seg_length_z=e.wood_ray_seg_length_z,this.wood_ray_num_slices=e.wood_ray_num_slices,this.wood_ray_ellipse_z2x=e.wood_ray_ellipse_z2x,this.wood_ray_ellipse_radius_x=e.wood_ray_ellipse_radius_x,this.wood_use_latewood_bump=e.wood_use_latewood_bump,this.wood_latewood_bump_depth=e.wood_latewood_bump_depth,this.wood_use_groove_roughness=e.wood_use_groove_roughness,this.wood_groove_roughness=e.wood_groove_roughness,this.wood_diffuse_lobe_weight=e.wood_diffuse_lobe_weight,this.uniforms.permutationMap.value=e.uniforms.permutationMap.value,this.uniforms.gradientMap.value=e.uniforms.gradientMap.value,this.uniforms.perm2DMap.value=e.uniforms.perm2DMap.value,this.uniforms.permGradMap.value=e.uniforms.permGradMap.value,void 0!==e.wood_curly_distortion_map&&(this.wood_curly_distortion_map=e.wood_curly_distortion_map,this.wood_curly_distortion_enable=e.wood_curly_distortion_enable,this.wood_curly_distortion_scale=e.wood_curly_distortion_scale),this.wood_ring_fraction=e.wood_ring_fraction,this.wood_fall_rise=e.wood_fall_rise;break;default:console.warn("Unknown prism type: "+e.prismType)}this.envExponentMin=e.envExponentMin,this.envExponentMax=e.envExponentMax,this.envExponentCount=e.envExponentCount,this.envMap=e.envMap,e.useTiling&&(this.useTiling=e.useTiling,this.tilingOverallTransform=(new THREE.Matrix4).copy(e.tilingOverallTransform),this.TilingMap=e.TilingMap,this.TilingMap_texMatrix=(new THREE.Matrix3).copy(e.TilingMap_texMatrix),this.hasRoundCorner=e.hasRoundCorner,this.hasRoundCorner&&(this.TilingNormalMap=e.TilingNormalMap,this.TilingNormalMap_texMatrix=(new THREE.Matrix3).copy(e.TilingNormalMap_texMatrix)),this.useRandomOffset=e.useRandomOffset,this.useRandomOffset&&(this.TilingRandomMap=e.TilingRandomMap,this.TilingRandomMap_texMatrix=(new THREE.Matrix3).copy(e.TilingRandomMap_texMatrix),this.tilingRandomAxisS=(new THREE.Vector2).copy(e.tilingRandomAxisS),this.tilingRandomAxisT=(new THREE.Vector2).copy(e.tilingRandomAxisT),this.tilingRandomAlignmentOffset=(new THREE.Vector2).copy(e.tilingRandomAlignmentOffset)),this.uv2tile=e.uv2tile,this.tile2uv=e.tile2uv,this.tilingRepeatRange=[e.tilingRepeatRange[0],e.tilingRepeatRange[1],e.tilingRepeatRange[2],e.tilingRepeatRange[3]],this.tileAlignOffset=(new THREE.Vector2).copy(e.tileAlignOffset),this.tilingUVTransform=(new THREE.Matrix4).copy(e.tilingUVTransform)),this.defines=e.defines}},{key:"refreshUniforms",value:function(e){var n=this;switch(e.exposureBias.value=n.exposureBias,e.opacity.value=n.opacity,e.surface_albedo.value=n.surface_albedo,e.surface_roughness.value=n.surface_roughness,e.surface_anisotropy.value=n.surface_anisotropy,e.surface_rotation.value=n.surface_rotation,A(e,n,"surface_albedo_map"),A(e,n,"surface_roughness_map"),A(e,n,"surface_cutout_map"),A(e,n,"surface_anisotropy_map"),A(e,n,"surface_rotation_map"),b(e,n,"surface_normal_map"),n.prismType){case"PrismOpaque":e.opaque_albedo.value=n.opaque_albedo,e.opaque_luminance_modifier.value=n.opaque_luminance_modifier,e.opaque_f0.value=n.opaque_f0,e.opaque_luminance.value=n.opaque_luminance,A(e,n,"opaque_albedo_map"),A(e,n,"opaque_luminance_modifier_map"),A(e,n,"opaque_f0_map");break;case"PrismMetal":e.metal_f0.value=n.metal_f0,A(e,n,"metal_f0_map");break;case"PrismLayered":e.layered_f0.value=n.layered_f0,e.layered_diffuse.value=n.layered_diffuse,e.layered_fraction.value=n.layered_fraction,e.layered_bottom_f0.value=n.layered_bottom_f0,e.layered_roughness.value=n.layered_roughness,e.layered_anisotropy.value=n.layered_anisotropy,e.layered_rotation.value=n.layered_rotation,A(e,n,"layered_bottom_f0_map"),A(e,n,"layered_f0_map"),A(e,n,"layered_diffuse_map"),A(e,n,"layered_fraction_map"),A(e,n,"layered_roughness_map"),A(e,n,"layered_anisotropy_map"),A(e,n,"layered_rotation_map"),b(e,n,"layered_normal_map");break;case"PrismTransparent":e.transparent_color.value=n.transparent_color,e.transparent_distance.value=n.transparent_distance,e.transparent_ior.value=n.transparent_ior;break;case"PrismGlazing":e.glazing_f0.value=n.glazing_f0,e.glazing_transmission_color.value=n.glazing_transmission_color,e.glazing_transmission_roughness.value=n.glazing_transmission_roughness,A(e,n,"glazing_f0_map"),A(e,n,"glazing_transmission_color_map"),A(e,n,"glazing_transmission_roughness_map");break;case"PrismWood":e.wood_fiber_cosine_enable.value=n.wood_fiber_cosine_enable,e.wood_fiber_cosine_bands.value=n.wood_fiber_cosine_bands,e.wood_fiber_cosine_weights.value=n.wood_fiber_cosine_weights,e.wood_fiber_cosine_frequencies.value=n.wood_fiber_cosine_frequencies,e.wood_fiber_perlin_enable.value=n.wood_fiber_perlin_enable,e.wood_fiber_perlin_bands.value=n.wood_fiber_perlin_bands,e.wood_fiber_perlin_weights.value=n.wood_fiber_perlin_weights,e.wood_fiber_perlin_frequencies.value=n.wood_fiber_perlin_frequencies,e.wood_fiber_perlin_scale_z.value=n.wood_fiber_perlin_scale_z,e.wood_growth_perlin_enable.value=n.wood_growth_perlin_enable,e.wood_growth_perlin_bands.value=n.wood_growth_perlin_bands,e.wood_growth_perlin_weights.value=n.wood_growth_perlin_weights,e.wood_growth_perlin_frequencies.value=n.wood_growth_perlin_frequencies,e.wood_latewood_ratio.value=n.wood_latewood_ratio,e.wood_earlywood_sharpness.value=n.wood_earlywood_sharpness,e.wood_latewood_sharpness.value=n.wood_latewood_sharpness,e.wood_ring_thickness.value=n.wood_ring_thickness,e.wood_earlycolor_perlin_enable.value=n.wood_earlycolor_perlin_enable,e.wood_earlycolor_perlin_bands.value=n.wood_earlycolor_perlin_bands,e.wood_earlycolor_perlin_weights.value=n.wood_earlycolor_perlin_weights,e.wood_earlycolor_perlin_frequencies.value=n.wood_earlycolor_perlin_frequencies,e.wood_early_color.value=n.wood_early_color,e.wood_use_manual_late_color.value=n.wood_use_manual_late_color,e.wood_manual_late_color.value=n.wood_manual_late_color,e.wood_latecolor_perlin_enable.value=n.wood_latecolor_perlin_enable,e.wood_latecolor_perlin_bands.value=n.wood_latecolor_perlin_bands,e.wood_latecolor_perlin_weights.value=n.wood_latecolor_perlin_weights,e.wood_latecolor_perlin_frequencies.value=n.wood_latecolor_perlin_frequencies,e.wood_late_color_power.value=n.wood_late_color_power,e.wood_diffuse_perlin_enable.value=n.wood_diffuse_perlin_enable,e.wood_diffuse_perlin_bands.value=n.wood_diffuse_perlin_bands,e.wood_diffuse_perlin_weights.value=n.wood_diffuse_perlin_weights,e.wood_diffuse_perlin_frequencies.value=n.wood_diffuse_perlin_frequencies,e.wood_diffuse_perlin_scale_z.value=n.wood_diffuse_perlin_scale_z,e.wood_use_pores.value=n.wood_use_pores,e.wood_pore_type.value=n.wood_pore_type,e.wood_pore_radius.value=n.wood_pore_radius,e.wood_pore_cell_dim.value=n.wood_pore_cell_dim,e.wood_pore_color_power.value=n.wood_pore_color_power,e.wood_pore_depth.value=n.wood_pore_depth,e.wood_use_rays.value=n.wood_use_rays,e.wood_ray_color_power.value=n.wood_ray_color_power,e.wood_ray_seg_length_z.value=n.wood_ray_seg_length_z,e.wood_ray_num_slices.value=n.wood_ray_num_slices,e.wood_ray_ellipse_z2x.value=n.wood_ray_ellipse_z2x,e.wood_ray_ellipse_radius_x.value=n.wood_ray_ellipse_radius_x,e.wood_use_latewood_bump.value=n.wood_use_latewood_bump,e.wood_latewood_bump_depth.value=n.wood_latewood_bump_depth,e.wood_use_groove_roughness.value=n.wood_use_groove_roughness,e.wood_groove_roughness.value=n.wood_groove_roughness,e.wood_diffuse_lobe_weight.value=n.wood_diffuse_lobe_weight,A(e,n,"wood_curly_distortion_map"),null!=e.wood_curly_distortion_map.value&&(e.wood_curly_distortion_map.value.minFilter=THREE.NearestFilter,e.wood_curly_distortion_map.value.magFilter=THREE.NearestFilter,e.wood_curly_distortion_enable.value=n.wood_curly_distortion_enable,e.wood_curly_distortion_scale.value=n.wood_curly_distortion_scale);var o=1-n.wood_latewood_ratio,a=n.wood_earlywood_sharpness*o,r=n.wood_latewood_sharpness*n.wood_latewood_ratio,t=o+r;e.wood_ring_fraction.value=new THREE.Vector4(o,a,r,t),e.wood_fall_rise.value=new THREE.Vector2(o-a,n.wood_latewood_ratio-r);break;default:console.warn("Unknown prism type: "+n.prismType)}n.useTiling&&(e.tilingOverallTransform.value=n.tilingOverallTransform,e.TilingMap.value=n.TilingMap,e.TilingMap_texMatrix.value=n.TilingMap_texMatrix,n.hasRoundCorner&&(e.TilingNormalMap.value=n.TilingNormalMap,e.TilingNormalMap_texMatrix.value=n.TilingNormalMap_texMatrix),n.useRandomOffset&&(e.TilingRandomMap.value=n.TilingRandomMap,e.TilingRandomMap_texMatrix.value=n.TilingRandomMap_texMatrix,e.tilingRandomAxisS.value=n.tilingRandomAxisS,e.tilingRandomAxisT.value=n.tilingRandomAxisT,e.tilingRandomAlignmentOffset.value=n.tilingRandomAlignmentOffset),e.uv2tile.value=n.uv2tile,e.tile2uv.value=n.tile2uv,e.tileAlignOffset.value=n.tileAlignOffset,e.tilingUVTransform.value=n.tilingUVTransform),e.envExponentMin.value=n.envExponentMin,e.envExponentMax.value=n.envExponentMax,e.envExponentCount.value=n.envExponentCount,function(e,n){e.envMap&&(e.envMap.value=n.envMap),e.irradianceMap&&(e.irradianceMap.value=n.irradianceMap),e.envMapExposure&&(e.envMapExposure.value=n.envMapExposure),e.envRotationSin&&e.envRotationCos&&(e.envRotationSin.value=n.envRotationSin,e.envRotationCos.value=n.envRotationCos)}(e,n)}},{key:"onBeforeCompile",value:function(e){!function(e,n){if(n.textureMaps)for(var o=0;o<N.length;o++){var a=N[o],r=n.textureMaps[a+"_map"];if(r){var t=r.textureObj.properties.booleans;e[a]={S:!t.texture_URepeat.values[0],T:!t.texture_VRepeat.values[0]}}}}(e,this),Autodesk.Viewing.Private.patchShader(e,{fragmentHeader:P(e),vertexHeader:"\n      #ifdef PRISMWOOD\n          attribute vec3 uvw;\n      #endif"})}}])&&T(n.prototype,o),a&&T(n,a),t}();H.prototype.isPrismMaterial=!0;var I=-1e240;function O(){this.distance=I,this.dot=1}function L(e,n){return e.x*n.y-e.y*n.x}function D(e,n,o){var a=e.length();return 0===a?n?new THREE.Vector2(0,o?0:1):new THREE.Vector2(0,-(o?0:1)):n?new THREE.Vector2(-e.y/a,e.x/a):new THREE.Vector2(e.y/a,-e.x/a)}O.prototype={constructor:O,set:function(e,n){return this.distance=e,this.dot=n,this},copy:function(e){this.distance=e.distance,this.dot=e.dot},lessThan:function(e){return Math.abs(this.distance)<Math.abs(e.distance)||Math.abs(this.distance)===Math.abs(e.distance)&&this.dot<e.dot},greaterThan:function(e){return Math.abs(this.distance)>Math.abs(e.distance)||Math.abs(this.distance)===Math.abs(e.distance)&&this.dot>e.dot},lessThanOrEquals:function(e){return Math.abs(this.distance)<Math.abs(e.distance)||Math.abs(this.distance)==Math.abs(e.distance)&&this.dot<=e.dot},greaterThanOrEquals:function(e){return Math.abs(this.distance)>Math.abs(e.distance)||Math.abs(this.distance)==Math.abs(e.distance)&&this.dot>=e.dot}};function U(e,n,o){this.p=[],this.p[0]=e.clone(),this.p[1]=n.clone(),this.color=o}function V(e,n){return(n.x-e.x)*(e.y+n.y)}function z(){this.edges=[]}function F(e,n,o){return e.dot(n)<=0||Math.abs(L(e,n))>o}function C(e,n){return G(e,n,0)}function G(e,n,o){var a=e&o;if(1==a||2==a||4==a)return[e=7^a,n];if(0==e||7==e)return[e=[6,5,3][n%3],n=Math.floor(n/3)];var r=e<<1+(1&n);return[e=7&(r|r>>3),n>>=1]}function q(){this.minDistance=new O,this.nearEdge=null,this.nearParam=0}function B(e,n,o){return Math.max(Math.min(e,n),Math.min(Math.max(e,n),o))}function W(e,n){var o=n.point(0),a=n.point(1),r=e,t=e.clone().sub(o),i=a.clone().sub(o),l=t.dot(i)/i.dot(i);return l<0?t.length():l>1?r.clone().sub(a).length():Math.abs(D(i,!1,!1).dot(t))}function Y(){this.contours=[],this.windings=[],this.inverseYAxis=!1}U.prototype={constructor:U,set:function(e){return this.color=e,this},clone:function(){return new this.constructor(this.p[0],this.p[1],this.color)},point:function(e){return this.p[0].clone().lerp(this.p[1],e)},direction:function(){return this.p[1].clone().sub(this.p[0])},signedDistance:function(e){var n=e.clone().sub(this.p[0]),o=this.direction(),a=n.dot(o)/o.dot(o),r=this.p[a>.5?1:0].clone().sub(e),t=r.length();if(a>0&&a<1){var i=D(o,!1,!1).dot(n);if(Math.abs(i)<t){var l=new O;return l.set(i,0),[l,a]}}var s=2*(L(n,o)>0?1:0)-1,_=new O;return _.set(s*t,Math.abs(o.normalize().dot(r.normalize(r)))),[_,a]},distanceToPseudoDistance:function(e,n,o){var a,r;if(o<0){r=this.direction().normalize();var t=n.clone().sub(this.p[0]);t.dot(r)<0&&(a=L(t,r),Math.abs(a)<=Math.abs(e.distance)&&(e.distance=a,e.dot=0))}else if(o>1){r=this.direction().normalize();var i=n.clone().sub(this.p[1]);i.dot(r)>0&&(a=L(i,r),Math.abs(a)<=Math.abs(e.distance)&&(e.distance=a,e.dot=0))}},moveStartPoint:function(e){this.p[0].copy(e)},moveEndPoint:function(e){this.p[1].copy(e)},splitInThirds:function(e,n,o){var a=this.point(1/3),r=this.point(2/3);new U(this.p[0],a,this.color),new U(a,r,this.color),new U(r,this.p[1],this.color)}},z.prototype={constructor:z,addEdge:function(e){this.edges.push(e)},winding:function(){if(0===this.edges.length)return 0;var e,n,o,a,r,t=0;if(1==this.edges.length)e=new THREE.Vector2,n=new THREE.Vector2,o=new THREE.Vector2,e.copy(this.edges[0].point(0)),n.copy(this.edges[0].point(1/3)),o.copy(this.edges[0].point(2/3)),t+=V(e,n),t+=V(n,o),t+=V(o,e);else if(2==this.edges.length)e=new THREE.Vector2,n=new THREE.Vector2,o=new THREE.Vector2,a=new THREE.Vector2,e.copy(this.edges[0].point(0)),n.copy(this.edges[0].point(.5)),o.copy(this.edges[1].point(0)),a.copy(this.edges[1].point(.5)),t+=V(e,n),t+=V(n,o),t+=V(o,a),t+=V(a,e);else{var i=new THREE.Vector2,l=new THREE.Vector2;i=this.edges[this.edges.length-1].point(0);for(var s=0;s<this.edges.length;s++)t+=V(i,l=this.edges[s].point(0)),i=l}return(r=t)>0?1:r<0?-1:0}},q.prototype={constructor:q,clear:function(){this.nearEdge=null,this.nearParam=0},copy:function(e){this.minDistance.copy(e.minDistance),this.nearEdge=e.nearEdge,this.nearParam=e.nearParam}},Y.prototype={constructor:Y,addContour:function(e){this.contours.push(e)},addBlankContour:function(){var e=new z;return this.contours.push(e),e},initialize:function(){for(var e=0;e<this.contours.length;++e){var n=this.contours[e];this.windings.push(n.winding())}},edgeColoringSimple:function(e,n){for(var o=Math.sin(e),a=0;a<this.contours.length;++a){var r=this.contours[a],t=[];if(r.edges.length>0)for(var i=r.edges[r.edges.length-1].direction(1),l=0;l<r.edges.length;++l){var s=r.edges[l];F(i.normalize(),s.direction(0).normalize(),o)&&t.push(l),i=s.direction(1)}if(0===t.length)for(var _=0;_<r.edges.length;++_)r.edges[_].color=7;else if(1==t.length){var f=[7,7],d=C(f[0],n);f[0]=d[0],n=d[1],f[2]=f[0],d=C(f[0],n),f[0]=d[0],n=d[1];var u=t[0];if(r.edges.length>=3)for(var c=r.edges.length,p=0;p<c;++p)r.edges[(u+p)%c].color=f[Math.floor(2.875*p/(c-1)+.0625)];else if(r.edges.length>=1){var m=[];r.edges[0].splitInThirds(m[0+3*u],m[1+3*u],m[2+3*u]),r.edges.length>=2?(r.edges[1].splitInThirds(m[3-3*u],m[4-3*u],m[5-3*u]),m[0].color=m[1].color=f[0],m[2].color=m[3].color=f[1],m[4].color=m[5].color=f[2]):(m[0].color=f[0],m[1].color=f[1],m[2].color=f[2]),r.edges.clear();for(var v=0;v<m.length;++v)r.edges.push(m[v])}}else{var g=t.length,y=0,E=t[0],h=r.edges.length,T=7,R=C(T,n);T=R[0],n=R[1];for(var w=T,M=0;M<h;++M){var x=(E+M)%h;y+1<g&&t[y+1]==x&&(T=(R=G(T,n,(++y===g-1?1:0)*w))[0],n=R[1]),r.edges[x].color=T}}}},calculateMSDFValue:function(e){for(var n=this.contours.length,o=[],a=new q,r=new q,t=new q,i=Math.abs(I),l=-I,s=I,_=0,f=new q,d=new q,u=new q,c=0;c<this.contours.length;++c){o[c]={r:I,g:I,b:I,med:I};var p=this.contours[c];f.clear(),d.clear(),u.clear();for(var m=0;m<p.edges.length;++m){var v=p.edges[m],g=v.signedDistance(e),y=g[0],E=g[1];(1&v.color)>0&&y.lessThan(f.minDistance)&&(f.minDistance.copy(y),f.nearEdge=v,f.nearParam=E),(2&v.color)>0&&y.lessThan(d.minDistance)&&(d.minDistance.copy(y),d.nearEdge=v,d.nearParam=E),(4&v.color)>0&&y.lessThan(u.minDistance)&&(u.minDistance.copy(y),u.nearEdge=v,u.nearParam=E)}f.minDistance.lessThan(a.minDistance)&&a.copy(f),d.minDistance.lessThan(r.minDistance)&&r.copy(d),u.minDistance.lessThan(t.minDistance)&&t.copy(u);var h=Math.abs(B(f.minDistance.distance,d.minDistance.distance,u.minDistance.distance));h<i&&(i=h,_=-this.windings[c]),f.nearEdge&&f.nearEdge.distanceToPseudoDistance(f.minDistance,e,f.nearParam),d.nearEdge&&d.nearEdge.distanceToPseudoDistance(d.minDistance,e,d.nearParam),u.nearEdge&&u.nearEdge.distanceToPseudoDistance(u.minDistance,e,u.nearParam),h=B(f.minDistance.distance,d.minDistance.distance,u.minDistance.distance),o[c].r=f.minDistance.distance,o[c].g=d.minDistance.distance,o[c].b=u.minDistance.distance,o[c].med=h,this.windings[c]>0&&h>=0&&Math.abs(h)<Math.abs(s)&&(s=h),this.windings[c]<0&&h<=0&&Math.abs(h)<Math.abs(l)&&(l=h)}a.nearEdge&&a.nearEdge.distanceToPseudoDistance(a.minDistance,e,a.nearParam),r.nearEdge&&r.nearEdge.distanceToPseudoDistance(r.minDistance,e,r.nearParam),t.nearEdge&&t.nearEdge.distanceToPseudoDistance(t.minDistance,e,t.nearParam);var T={r:I,g:I,b:I,med:I};if(s>=0&&Math.abs(s)<=Math.abs(l)){T.med=I,_=1;for(var R=0;R<n;++R)this.windings[R]>0&&o[R].med>T.med&&Math.abs(o[R].med)<Math.abs(l)&&(T=o[R])}else if(l<=0&&Math.abs(l)<=Math.abs(s)){T.med=-I,_=-1;for(var w=0;w<n;++w)this.windings[w]<0&&o[w].med<T.med&&Math.abs(o[w].med)<Math.abs(s)&&(T=o[w])}for(var M=0;M<n;++M)this.windings[M]!=_&&Math.abs(o[M].med)<Math.abs(T.med)&&(T=o[M]);return B(a.minDistance.distance,r.minDistance.distance,t.minDistance.distance)==T.med&&(T.r=a.minDistance.distance,T.g=r.minDistance.distance,T.b=t.minDistance.distance),new THREE.Vector3(T.r,T.g,T.b)},minSameColoredEdgeDistance:function(){for(var e=[1e10,1e10,1e10],n=0;n<this.contours.length;++n)for(var o=this.contours[n],a=0;a<o.edges.length;++a)for(var r=o.edges[a],t=0;t+1<a;++t){var i=o.edges[t];if(r.color==i.color){var l=Math.min(Math.min(W(r.point(0),i),W(r.point(1),i)),Math.min(W(i.point(0),r),W(i.point(1),r))),s=r.color-5;e[s]=Math.min(e[s],l)}}return Math.min(Math.min(e[0],e[1]),e[2])}};var X,k,j=Autodesk.Viewing.Private.MaterialConverterCommon,Q=j.parseMaterialGeneric,Z=j.parseMaterialColor,K=j.parseMaterialScalar,J=j.SRGBToLinear,$={MilliMeter:1e3,mm:1e3,8206:1e3,DeciMeter:10,dm:10,8204:10,CentiMeter:100,cm:100,8205:100,Meter:1,m:1,8193:1,KiloMeter:.001,km:.001,8201:.001,Inch:39.37008,in:39.37008,8214:39.37008,Foot:3.28084,ft:3.28084,8215:3.28084,Mile:62137e-8,mi:62137e-8,8225:62137e-8,Yard:1.09361,yard:1.09361,8221:1.09361};function ee(e,n,o,a){if(!e||!e.scalars)return a;var r=e.scalars[n];return r?function(e,n,o){var a=$[o];a||(a=1,console.warn("Unsupported unit: "+o));var r=$[n];return r||(r=1,console.warn("Unsupported unit: "+n)),e*a/r}(r.values[0],r.units,o):a}function ne(e,n,o,a){if(!e||!e[n])return a;var r=e[n][o];return r&&r.connections?r.connections[0]:a}function oe(e,n){var o=ee(e,"texture_RealWorldOffsetX",n,0),a=ee(e,"texture_RealWorldOffsetY",n,0),r=Q(e,"scalars","texture_UOffset",0),t=Q(e,"scalars","texture_VOffset",0),i=1,l=1;null!=Q(e,"scalars","texture_RealWorldScale")?i=l=ee(e,"texture_RealWorldScale",n,1):(i=ee(e,"texture_RealWorldScaleX",n,1),l=ee(e,"texture_RealWorldScaleY",n,1)),i=0===i?1:i,l=0===l?1:l;var s=Q(e,"scalars","texture_UScale",1),_=Q(e,"scalars","texture_VScale",1),f=Q(e,"scalars","texture_WAngle",0);f*=Math.PI/180;var d=Math.cos(f),u=Math.sin(f),c=s/i,p=_/l;return{elements:[d*c,u*c,0,-u*p,d*p,0,-d*c*o+u*p*a+r,-u*c*o-d*p*a+t,1]}}function ae(e){var n=k;return k=e,n}function re(e){e&&(e.permutation.dispose(),e.gradient.dispose(),e.perm2D.dispose(),e.permGrad.dispose())}function te(e,n,o){e[o+"_enable"]=Q(n,"booleans",o+"_enable",0);var a=function(e,n,o){var a={bands:0,weights:new THREE.Vector4(1,1,1,1),frequencies:new THREE.Vector4(1,1,1,1)};if(!e||!e[n])return a;var r=e[n][o];if(!(r&&r.values&&r.values instanceof Array))return a;var t=r.values;a.bands=t.length/2;for(var i=0;i<a.bands;++i)a.frequencies.setComponent(i,1/t[2*i]),a.weights.setComponent(i,t[2*i+1]);return a}(n,"scalars",o+"_prof");e[o+"_bands"]=a.bands,e[o+"_weights"]=a.weights,e[o+"_frequencies"]=a.frequencies}function ie(e,n,o,a){a=a||e.userassets;var r=e.materials,t=r[a];t&&("TilingPattern"===t.definition&&(t=r[t.properties.references.grout_material.connections[0]]));var i,l,s=t.properties;if(o){if(!o.isPrismMaterial)return null;o.needsUpdate=!0}else o=new H;o.proteinMat=e,o.proteinCategories=t.categories,o.packedNormals=!0,o.tag=t.tag,o.prismType=t.definition,void 0===o.prismType&&(o.prismType=""),void 0!==e.IsSingleSided&&!1===e.IsSingleSided&&(o.side=THREE.DoubleSide);var _=o.mapList;switch(o.transparent=!1,o.envExponentMin=1,o.envExponentMax=512,o.envExponentCount=10,o.surface_albedo=J(Z(s,"surface_albedo",new THREE.Color(1,0,0))),_.surface_albedo_map=ne(s,"colors","surface_albedo",null),o.surface_anisotropy=Q(s,"scalars","surface_anisotropy",0),_.surface_anisotropy_map=ne(s,"scalars","surface_anisotropy",null),o.surface_rotation=Q(s,"scalars","surface_rotation",0),_.surface_rotation_map=ne(s,"scalars","surface_rotation",null),o.surface_roughness=Q(s,"scalars","surface_roughness",0),_.surface_roughness_map=ne(s,"scalars","surface_roughness",null),_.surface_cutout_map=ne(s,"textures","surface_cutout",null),_.surface_normal_map=ne(s,"textures","surface_normal",null),null!=_.surface_cutout_map&&(o.side=THREE.DoubleSide,o.transparent=!0),o.prismType){case"PrismOpaque":o.opaque_albedo=J(Z(s,"opaque_albedo",new THREE.Color(1,0,0))),_.opaque_albedo_map=ne(s,"colors","opaque_albedo",null),o.opaque_luminance_modifier=J(Z(s,"opaque_luminance_modifier",new THREE.Color(0,0,0))),_.opaque_luminance_modifier_map=ne(s,"colors","opaque_luminance_modifier",null),o.opaque_f0=Q(s,"scalars","opaque_f0",0),_.opaque_f0_map=ne(s,"scalars","opaque_f0",null),o.opaque_luminance=Q(s,"scalars","opaque_luminance",0);break;case"PrismMetal":o.metal_f0=J(Z(s,"metal_f0",new THREE.Color(1,0,0))),_.metal_f0_map=ne(s,"colors","metal_f0",null);break;case"PrismLayered":o.layered_bottom_f0=J(Z(s,"layered_bottom_f0",new THREE.Color(1,1,1))),_.layered_bottom_f0_map=ne(s,"colors","layered_bottom_f0",null),o.layered_diffuse=J(Z(s,"layered_diffuse",new THREE.Color(1,0,0))),_.layered_diffuse_map=ne(s,"colors","layered_diffuse",null),o.layered_anisotropy=Q(s,"scalars","layered_anisotropy",0),_.layered_anisotropy_map=ne(s,"scalars","layered_anisotropy",null),o.layered_f0=Q(s,"scalars","layered_f0",0),_.layered_f0_map=ne(s,"scalars","layered_f0",null),o.layered_fraction=Q(s,"scalars","layered_fraction",0),_.layered_fraction_map=ne(s,"scalars","layered_fraction",null),o.layered_rotation=Q(s,"scalars","layered_rotation",0),_.layered_rotation_map=ne(s,"scalars","layered_rotation",null),o.layered_roughness=Q(s,"scalars","layered_roughness",0),_.layered_roughness_map=ne(s,"scalars","layered_roughness",null),_.layered_normal_map=ne(s,"textures","layered_normal",null);break;case"PrismTransparent":o.transparent_color=J(Z(s,"transparent_color",new THREE.Color(1,0,0))),o.transparent_distance=Q(s,"scalars","transparent_distance",0),o.transparent_ior=Q(s,"scalars","transparent_ior",0),o.transparent=!0;break;case"PrismGlazing":o.glazing_f0=J(Z(s,"glazing_f0",new THREE.Color(1,1,1))),_.glazing_f0_map=ne(s,"colors","glazing_f0",null),o.glazing_transmission_color=J(Z(s,"glazing_transmission_color",new THREE.Color(1,1,1))),_.glazing_transmission_color_map=ne(s,"colors","glazing_transmission_color",null),o.glazing_transmission_roughness=K(s,"glazing_transmission_roughness",0),_.glazing_transmission_roughness_map=ne(s,"scalars","glazing_transmission_roughness",null),o.side=Q(s,"booleans","glazing_backface_culling",!1)?THREE.FrontSide:THREE.DoubleSide,o.transparent=!0;break;case"PrismWood":te(o,s,"wood_fiber_cosine"),te(o,s,"wood_fiber_perlin"),o.wood_fiber_perlin_scale_z=Q(s,"scalars","wood_fiber_perlin_scale_z",0),te(o,s,"wood_growth_perlin"),o.wood_latewood_ratio=Q(s,"scalars","wood_latewood_ratio",0),o.wood_earlywood_sharpness=Q(s,"scalars","wood_earlywood_sharpness",0),o.wood_latewood_sharpness=Q(s,"scalars","wood_latewood_sharpness",0),o.wood_ring_thickness=Q(s,"scalars","wood_ring_thickness",0),te(o,s,"wood_earlycolor_perlin"),o.wood_early_color=J(Z(s,"wood_early_color",new THREE.Color(1,0,0))),o.wood_use_manual_late_color=Q(s,"booleans","wood_use_manual_late_color",0),o.wood_manual_late_color=J(Z(s,"wood_manual_late_color",new THREE.Color(1,0,0))),te(o,s,"wood_latecolor_perlin"),o.wood_late_color_power=Q(s,"scalars","wood_late_color_power",0),te(o,s,"wood_diffuse_perlin"),o.wood_diffuse_perlin_scale_z=Q(s,"scalars","wood_diffuse_perlin_scale_z",0),o.wood_use_pores=Q(s,"booleans","wood_use_pores",0),o.wood_pore_type=Q(s,"choicelists","wood_pore_type",0),o.wood_pore_radius=Q(s,"scalars","wood_pore_radius",0),o.wood_pore_cell_dim=Q(s,"scalars","wood_pore_cell_dim",0),o.wood_pore_color_power=Q(s,"scalars","wood_pore_color_power",0),o.wood_pore_depth=Q(s,"scalars","wood_pore_depth",0),o.wood_use_rays=Q(s,"booleans","wood_use_rays",0),o.wood_ray_color_power=Q(s,"scalars","wood_ray_color_power",0),o.wood_ray_seg_length_z=Q(s,"scalars","wood_ray_seg_length_z",0),o.wood_ray_num_slices=Q(s,"integers","wood_ray_num_slices",0),o.wood_ray_ellipse_z2x=Q(s,"scalars","wood_ray_ellipse_z2x",0),o.wood_ray_ellipse_radius_x=Q(s,"scalars","wood_ray_ellipse_radius_x",0),o.wood_use_latewood_bump=Q(s,"booleans","wood_use_latewood_bump",0),o.wood_latewood_bump_depth=Q(s,"scalars","wood_latewood_bump_depth",0),o.wood_use_groove_roughness=Q(s,"booleans","wood_use_groove_roughness",0),o.wood_groove_roughness=Q(s,"scalars","wood_groove_roughness",0),o.wood_diffuse_lobe_weight=Q(s,"scalars","wood_diffuse_lobe_weight",0),o.wood_curly_distortion_enable=Q(s,"booleans","wood_curly_distortion_enable",0),o.wood_curly_distortion_scale=Q(s,"scalars","wood_curly_distortion_scale",0),_.wood_curly_distortion_map=ne(s,"scalars","wood_curly_distortion_map",null),k||function(){var e=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],n=new Uint8Array(e),o=new THREE.DataTexture(n,256,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);o.generateMipmaps=!1,o.flipY=!1,o.needsUpdate=!0;var a=new Uint8Array([225,39,122,231,29,173,15,159,75,88,233,19,179,79,72,94,54,73,151,161,171,113,221,144,127,83,168,19,88,122,62,225,109,128,246,247,172,101,61,139,211,168,64,210,224,82,87,97,119,250,201,44,242,239,154,99,126,13,44,70,246,170,100,52,135,28,187,22,207,119,199,1,235,187,55,131,190,124,222,249,236,53,225,231,71,30,173,185,153,47,79,133,225,10,140,62,17,99,100,29,137,95,142,244,76,5,83,124,38,216,253,195,44,210,148,185,188,39,78,195,132,30,60,73,92,223,133,80,230,56,118,207,79,15,251,211,111,21,79,23,240,146,150,207,3,61,103,27,148,6,31,127,235,58,173,244,116,81,34,120,192,213,188,226,97,23,16,161,106,80,242,148,35,37,91,117,51,216,97,193,126,222,39,38,133,217,215,23,237,57,205,42,222,165,126,133,33,8,227,154,27,18,56,11,192,120,80,92,236,38,210,207,128,31,135,39,123,5,49,127,107,200,34,14,153,239,134,19,248,162,58,201,159,198,243,158,72,5,138,184,222,200,34,141,233,40,195,238,191,122,171,32,66,254,229,197]),r=new THREE.DataTexture(a,256,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);r.generateMipmaps=!1,r.flipY=!1,r.needsUpdate=!0;for(var t,i,l,s,_,f,d,u,c=function(n){return e[n%256]},p=new Array(262144),m=0;m<256;++m)for(u=0;u<256;++u)t=c(u)+m,i=c(t),l=c(t+1),s=c(u+1)+m,_=c(s),f=c(s+1),p[d=4*(256*m+u)]=i,p[d+1]=l,p[d+2]=_,p[d+3]=f;var v=new Uint8Array(p),g=new THREE.DataTexture(v,256,256,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);g.generateMipmaps=!1,g.flipY=!1,g.needsUpdate=!0;var y=[1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1,1,1,0,0,-1,1,-1,1,0,0,-1,-1],E=new Array(1024);for(u=0;u<256;++u){var h=e[u]%16;E[4*u]=127*y[3*h]+128,E[4*u+1]=127*y[3*h+1]+128,E[4*u+2]=127*y[3*h+2]+128,E[4*u+3]=0}var T=new Uint8Array(E),R=new THREE.DataTexture(T,256,1,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);R.generateMipmaps=!1,R.flipY=!1,R.needsUpdate=!0,k={permutation:o,gradient:r,perm2D:g,permGrad:R}}(),o.uniforms.permutationMap.value=k.permutation,o.uniforms.gradientMap.value=k.gradient,o.uniforms.perm2DMap.value=k.perm2D,o.uniforms.permGradMap.value=k.permGrad;break;default:console.warn("Unknown prism type: "+o.prismType)}for(var f in o.enableImportantSampling&&(o.surface_anisotropy||o.surface_rotation||o.layered_anisotropy||o.layered_rotation)&&(X||function(){var e=new Uint8Array([0,128,64,191,32,160,96,223,16,143,80,207,48,175,112,239,8,135,72,199,40,167,103,231,25,151,88,215,56,183,120,250]),n=new THREE.DataTexture(e,32,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);n.generateMipmaps=!1,n.flipY=!1,n.needsUpdate=!0;for(var o,a,r=function(e,n){return Math.atan2(e*n,Math.sqrt(e*e+n*n+1))},t=new Uint8Array(16384),i=1/128,l=0;l<128;++l)for(var s=0;s<128;++s){o=l/128*2-1,a=s/128*2-1;var _=(o=Math.min(Math.max(-.9921875,o),.9921875))-i,f=o+i,d=(a=Math.min(Math.max(-.9921875,a),.9921875))-i,u=a+i,c=r(f,u)-r(_,u)-r(f,d)+r(_,d);t[128*l+s]=1e6*c}var p=new THREE.DataTexture(t,128,128,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);p.generateMipmaps=!1,p.flipY=!1,p.needsUpdate=!0,X={randomNum:n,solidAngle:p}}(),o.uniforms.importantSamplingRandomMap.value=X.randomNum,o.uniforms.importantSamplingSolidAngleMap.value=X.solidAngle),o.defines={},o.textureMaps={},_)if(_[f]){var d=r[_[f]];l=d.properties,d.matrix=Te(d,!0,n);var u="BumpMap"==d.definition?"bumpmap_Bitmap":"unifiedbitmap_Bitmap",c=l.uris[u].values,p=c[0];p&&(i={mapName:f,uri:p,uriPointer:c,textureObj:d,isPrism:!0},o.textureMaps[i.mapName]=i,o.defines["USE_"+f.toUpperCase()]="")}return o.defines[o.prismType.toUpperCase()]="","PrismWood"==o.prismType&&o.enable3DWoodBump&&(o.defines.PRISMWOODBUMP=""),o.enableImportantSampling&&(o.defines.ENABLEIMPORTANTSAMPLING=""),o}function le(e,n){if(0!==n.randomOffsetMode){e.tilingRandomAxisS=new THREE.Vector2,e.tilingRandomAxisT=new THREE.Vector2,e.tilingRandomAlignmentOffset=new THREE.Vector2;var o=e.tilingRandomAxisS;o.set(1,0);var a=e.tilingRandomAxisT;a.set(0,1);var r=e.tilingRandomAlignmentOffset;r.set(0,0);var t=new THREE.Matrix4,i=new THREE.Matrix4,l=function(e){var n=["opaque_albedo_map","opaque_f0_map","layered_diffuse_map","layered_bottom_f0_map","surface_roughness_map","surface_normal_map","surface_albedo_map","surface_anisotropy_map","surface_cutout_map"];if(void 0!==e.textureMaps)for(var o=0;o<n.length;++o)if(void 0!==e.textureMaps[n[o]]&&void 0!==e.textureMaps[n[o]].textureObj&&void 0!==e.textureMaps[n[o]].textureObj.matrix){var a=e.textureMaps[n[o]].textureObj.matrix.elements,r=new THREE.Matrix4;return r.set(a[0],a[1],0,a[2],a[3],a[4],0,a[5],0,0,1,0,a[6],a[7],0,a[8]),r}return new THREE.Matrix4}(e),s=function(e,n){var o=new THREE.Matrix4;o.makeScale(n.x,n.y,1);var a=new THREE.Matrix4;return a.makeTranslation(-e.x,-e.y,0),o.multiply(a),o}(new THREE.Vector2(0,1),new THREE.Vector2(1,-1));s.multiply(l),l.copy(s),t.multiplyMatrices(l,e.tilingUVTransform),i.copy(t).invert();var _=new THREE.Vector4(1,0,0,0).applyMatrix4(i);o.set(_.x,_.y),_=new THREE.Vector4(0,1,0,0).applyMatrix4(i),a.set(_.x,_.y);for(var f=new THREE.Vector2,d=new THREE.Box2,u=n.alignedVertices,c=0;c<u.length;c++)_.set(u[c].x,u[c].y,0,1),_.applyMatrix4(t),f.set(_.x,_.y),d.expandByPoint(f);_.set(-d.min.x,-d.min.y,0,0),_.applyMatrix4(i),r.set(_.x,_.y);var p=d.getSize(new THREE.Vector3),m=1===n.randomOffsetMode?new THREE.Vector2(p.x,p.y):new THREE.Vector2(0,0);o.multiplyScalar(1-m.x),a.multiplyScalar(1-m.y)}}function se(e,n,o,a,r){var t,i,l=n.properties,s={overallTransform:new THREE.Matrix4,insetSize:0,hasRoundCorner:!1,cornerRoundingAngle:0,cornerRoundingSize:0,offsetVectorA:new THREE.Vector2,offsetVectorB:new THREE.Vector2},_=new THREE.Vector2(ee(l,"scale_factor_x",r,1),ee(l,"scale_factor_y",r,1)),f=ee(l,"overall_offset_vector_x",r,1),d=ee(l,"overall_offset_vector_y",r,1),u=K(l,"overall_rotation_angle",0)*Math.PI/180;!function(e,n,o,a){e.scale(a);var r=new THREE.Vector3(Math.sin(o.x),Math.sin(o.y),Math.sin(o.z)),t=new THREE.Vector3(Math.cos(o.x),Math.cos(o.y),Math.cos(o.z)),i=r.y*r.x,l=r.y*t.x,s=new THREE.Matrix4;s.set(t.z*t.y,r.z*t.y,-r.y,0,t.z*i-r.z*t.x,r.z*i+t.z*t.x,t.y*r.x,0,t.z*l+r.z*r.x,r.z*l-t.z*r.x,t.y*t.x,0,0,0,0,1),s.multiply(e),e.makeTranslation(n.x,n.y,n.z),e.multiply(s)}(s.overallTransform,new THREE.Vector3(-f,-d,0),new THREE.Vector3(0,0,-u),new THREE.Vector3(1,1,1)),s.insetSize=ee(l,"inset_size",r,1),s.cornerRoundingAngle=K(l,"overall_corner_rounding_angle",0)*Math.PI/180,s.cornerRoundingSize=ee(l,"overall_corner_rounding_size",r,1),s.offsetVectorA.x=K(l,"offset_vector_a_x",0)*_.x,s.offsetVectorA.y=K(l,"offset_vector_a_y",0)*_.y,s.offsetVectorB.x=K(l,"offset_vector_b_x",0)*_.x,s.offsetVectorB.y=K(l,"offset_vector_b_y",0)*_.y,s.hasRoundCorner=s.cornerRoundingAngle>0&&s.cornerRoundingSize>0;var c=[];for(t=0,i=o.length;t<i;t++){var p=o[t].properties,m={material:a[t].material,randomOffsetMode:0,rotation:0,vertices:[]};c[t]=m,m.randomOffsetMode=Q(p,"choicelists","random_offset_mode",0),m.rotation=K(p,"rotation_angle",0)*Math.PI/180;for(var v=p.scalars.vertices.values,g=0;g<v.length;g+=2)m.vertices[g/2]=new THREE.Vector2(v[g],v[g+1]);for(var y=0;y<m.vertices.length;y++)m.vertices[y].multiply(_);m.material.useRandomOffset=0!=m.randomOffsetMode}!function(e,n){var o=new THREE.Box2;o.expandByPoint(new THREE.Vector2(0,0)),o.expandByPoint(e.offsetVectorA),o.expandByPoint(e.offsetVectorB);var a,r,t=new THREE.Vector2(e.offsetVectorA.x,e.offsetVectorA.y);for(t.add(e.offsetVectorB),o.expandByPoint(t),a=0,r=n.length;a<r;a++){var i=n[a];i.material.tilingRepeatRange=[],ve(e,i,i.material.tilingRepeatRange),i.bbox=new THREE.Box2;for(var l=0;l<i.vertices.length;++l)i.bbox.expandByPoint(i.vertices[l]);Ee(e,i),e.hasRoundCorner&&ue(e,i),i.material.useRandomOffset&&me(i,a),i.alignedVertices=[];for(var s=0;s<i.vertices.length;++s){var _=new THREE.Vector2(i.vertices[s].x,i.vertices[s].y);_.sub(i.bbox.min),i.alignedVertices.push(_)}i.material.tileAlignOffset=new THREE.Vector2(-i.bbox.min.x,-i.bbox.min.y)}}(s,c);var E,h,T,R,w=ge([s.offsetVectorA.clone(),s.offsetVectorB.clone()]);for(t=0,i=c.length;t<i;t++){var M=c[t],x=M.material;x.tilingOverallTransform=s.overallTransform,x.hasRoundCorner=s.hasRoundCorner,x.tilingUVTransform=(E=M.rotation,h=void 0,T=void 0,R=void 0,h=Math.sin(E),T=Math.cos(E),(R=new THREE.Matrix4).set(T,-h,0,0,h,T,0,0,0,0,1,0,0,0,0,1),R),x.useRandomOffset&&le(x,M),x.tile2uv=new THREE.Vector4(s.offsetVectorA.x,s.offsetVectorA.y,s.offsetVectorB.x,s.offsetVectorB.y),x.uv2tile=new THREE.Vector4(w[0].x,w[0].y,w[1].x,w[1].y)}}function _e(e,n,o){var a=new THREE.Vector2(o.x,o.y).sub(n),r=new THREE.Vector2(e.x,e.y).sub(n),t=a.dot(r);if(t<=0)return r.length();var i=a.dot(a);return t>=i?new THREE.Vector2(e).sub(o).length():Math.sqrt(Math.max(r.dot(r)-t*t/i,0))}function fe(e,n){for(var o=1e11,a=o,r=-1,t=0;t<e.vertices.length;t++){var i=t==e.vertices.length-1?0:t+1;(a=_e(n,e.vertices[t],e.vertices[i]))<o&&(o=a,r=t)}return[o,r]}function de(e,n,o){for(var a=e.length,r=a-1,t=!1,i=0;i<a;++i)(e[i].y<o&&e[r].y>=o||e[r].y<o&&e[i].y>=o)&&e[i].x+(o-e[i].y)/(e[r].y-e[i].y)*(e[r].x-e[i].x)<n&&(t=!t),r=i;return t}function ue(e,n){var o=n.bbox.getSize(new THREE.Vector3),a=2*e.cornerRoundingSize*.7071/3,r=ye(Math.ceil(o.x/a)+2,128,1024),t=ye(Math.ceil(o.y/a)+2,128,1024);r-=2,t-=2,o.x<o.y?t=Math.floor(r*o.y/o.x):r=Math.floor(t*o.x/o.y),r+=2,t+=2,function(e,n){e.normalToEdges=[];for(var o=e.vertices.length,a=Math.cos(n),r=Math.sin(n),t=0;t<o;++t){var i=t,l=t==o-1?0:t+1,s=new THREE.Vector2(e.vertices[l].x,e.vertices[l].y);s.sub(e.vertices[i]),s.normalize();var _=new THREE.Vector3(s.y*r,-s.x*r,a);e.normalToEdges.push(_)}e.cornerRoundingAngle=n}(n,e.cornerRoundingAngle);for(var i=new Uint8Array(r*t*4),l=new THREE.Vector2(o.x/(r-2),o.y/(t-2)),s=new THREE.Vector2,_=new THREE.Vector3,f=new THREE.Vector3(0,0,1),d=0,u=0;u<t;u++){s.y=(t-u-1.5)*l.y+n.bbox.min.y;for(var c=0;c<r;c++){s.x=(c-.5)*l.x+n.bbox.min.x;var p=fe(n,s),m=p[0],v=p[1];m<e.cornerRoundingSize+e.insetSize?(de(n.vertices,s.x,s.y)||(m=-m),_.copy(n.normalToEdges[v]),_.lerp(f,(m-e.insetSize)/e.cornerRoundingSize),_.normalize(),i[d++]=255*ye(.5*(_.x+1),0,1),i[d++]=255*ye(.5*(_.y+1),0,1),i[d++]=255*ye(.5*(_.z+1),0,1),i[d++]=255):(i[d++]=127,i[d++]=127,i[d++]=255,i[d++]=255)}}n.material.TilingNormalMap=new THREE.DataTexture(i,r,t,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.LinearFilter,THREE.LinearFilter),n.material.TilingNormalMap.needsUpdate=!0;var g=new THREE.Vector2(-n.bbox.min.x,-n.bbox.min.y);n.material.TilingNormalMap_texMatrix=new THREE.Matrix3,n.material.TilingNormalMap_texMatrix.set(1/o.x*(r-2)/r,0,0,0,1/o.y*(t-2)/t,0,g.x/o.x*(r-2)/r+1/r,g.y/o.y*(t-2)/t+1/t,1),n.material.TilingNormalMap_texMatrix.transpose()}function ce(e,n){return e<<n|e>>>32-n}function pe(e,n){var o,a,r;return o=a=r=3735928567+n,a+=e.y,function(e,n,o){var a=4294967296;return o=((o^=n)-ce(n,14)+a)%a,o=((o^=n=((n^=e=((e^=o)-ce(o,11)+a)%a)-ce(e,25)+a)%a)-ce(n,16)+a)%a,((o^=n=((n^=e=((e^=o)-ce(o,4)+a)%a)-ce(e,14)+a)%a)-ce(n,24)+a)%a}(o+=e.x,a,r)}function me(e,n){for(var o,a,r=512,t=512,i=new Uint8Array(1048576),l=new THREE.Vector2,s=new THREE.Vector2(107021*n,n),_=new THREE.Vector2,f=new THREE.Vector2,d=0,u=0;u<t;u++){l.y=Math.floor(-(u+1-256));for(var c=0;c<r;c++)l.x=Math.floor(c-256),_.copy(l),_.add(s),o=f,a=void 0,a=pe(_,33),o.x=(65535&a)>>>8,o.y=a>>>16>>>8,i[d++]=0,i[d++]=0,i[d++]=f.x,i[d++]=f.y}e.material.TilingRandomMap=new THREE.DataTexture(i,r,t,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter),e.material.TilingRandomMap.needsUpdate=!0,e.material.TilingRandomMap_texMatrix=new THREE.Matrix3,e.material.TilingRandomMap_texMatrix.set(1/r,0,0,0,1/t,0,.5,.5,1),e.material.TilingRandomMap_texMatrix.transpose()}function ve(e,n,o){var a=[];a[0]=new THREE.Vector2(e.offsetVectorA.x,e.offsetVectorB.x),a[1]=new THREE.Vector2(e.offsetVectorA.y,e.offsetVectorB.y);for(var r=ge(a),t=new THREE.Box2,i=new THREE.Vector2,l=0;l<n.vertices.length;++l)i.x=n.vertices[l].dot(r[0]),i.y=n.vertices[l].dot(r[1]),t.expandByPoint(i);o[0]=Math.floor(t.min.x-1),o[2]=Math.ceil(t.max.x),o[1]=Math.floor(t.min.y-1),o[3]=Math.ceil(t.max.y)}function ge(e){var n=e[0].x*e[1].y-e[0].y*e[1].x,o=[];return o[0]=new THREE.Vector2(e[1].y/n,-e[0].y/n),o[1]=new THREE.Vector2(-e[1].x/n,e[0].x/n),o}function ye(e,n,o){return e>o?o:e<n?n:e}function Ee(e,n){var o=new Y;!function(e,n){for(var o=e.addBlankContour(),a=new THREE.Vector2,r=new THREE.Vector2,t=0;t<n.vertices.length;++t){var i=t,l=(t+1)%n.vertices.length;a=n.vertices[i],r=n.vertices[l],o.addEdge(new U(a,r,7))}e.initialize(),e.edgeColoringSimple(3,0)}(o,n);for(var a=n.bbox.getSize(new THREE.Vector3),r=.7071*o.minSameColoredEdgeDistance()*.5,t=ye(Math.ceil(a.x/r)+2,16,512),i=ye(Math.ceil(a.y/r)+2,16,512),l=new Uint8Array(t*i*4),s=new THREE.Vector2(a.x/(t-2),a.y/(i-2)),_=.5/(s.x+s.y),f=new THREE.Vector2,d=new THREE.Vector3,u=0,c=0;c<i;c++){f.y=(i-c-1.5)*s.y+n.bbox.min.y;for(var p=0;p<t;p++)f.x=(p-.5)*s.x+n.bbox.min.x,d=(d=o.calculateMSDFValue(f)).add(new THREE.Vector3(e.insetSize,e.insetSize,e.insetSize)),l[u++]=255*ye(d.x*_+.5,0,1),l[u++]=255*ye(d.y*_+.5,0,1),l[u++]=255*ye(d.z*_+.5,0,1),l[u++]=0}n.material.TilingMap=new THREE.DataTexture(l,t,i,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.LinearFilter,THREE.LinearFilter),n.material.TilingMap.needsUpdate=!0;var m=new THREE.Vector2(-n.bbox.min.x,-n.bbox.min.y);n.material.TilingMap_texMatrix=new THREE.Matrix3,n.material.TilingMap_texMatrix.set(1/a.x*(t-2)/t,0,0,0,1/a.y*(i-2)/i,0,m.x/a.x*(t-2)/t+1/t,m.y/a.y*(i-2)/i+1/i,1),n.material.TilingMap_texMatrix.transpose()}function he(e,n,o){var a=e.properties;n.clampS=!Q(a,"booleans","texture_URepeat",!1),n.clampT=!Q(a,"booleans","texture_VRepeat",!1),n.wrapS=n.clampS?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,n.wrapT=n.clampT?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,n.matrix=e.matrix||(e.matrix=oe(a,o)),"UnifiedBitmap"==e.definition&&(n.invert=Q(a,"booleans","unifiedbitmap_Invert",!1)),"BumpMap"==e.definition&&(n.bumpmapType=Q(a,"choicelists","bumpmap_Type",0),n.bumpScale=function(e,n,o){if(0===n){var a=ee(e,"bumpmap_Depth",o,0),r=1,t=1;return null!=Q(e,"scalars","texture_RealWorldScale")?r=t=ee(e,"texture_RealWorldScale",o,1):(r=ee(e,"texture_RealWorldScaleX",o,1),t=ee(e,"texture_RealWorldScaleY",o,1)),r=0===r?1:1/r,t=0===t?1:1/t,new THREE.Vector2(r*a,t*a)}var i=Q(e,"scalars","bumpmap_NormalScale",1);return new THREE.Vector2(i,i)}(a,n.bumpmapType,o))}function Te(e,n,o){return e.matrix||(e.matrix=oe(e.properties,o)),e.matrix}function Re(e){return Re="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Re(e)}function we(e,n){for(var o=0;o<n.length;o++){var a=n[o];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function Me(e,n){return Me=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e},Me(e,n)}function xe(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var o,a=be(e);if(n){var r=be(this).constructor;o=Reflect.construct(a,arguments,r)}else o=a.apply(this,arguments);return Ae(this,o)}}function Ae(e,n){return!n||"object"!==Re(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function be(e){return be=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},be(e)}function Se(e,n){for(var o in e)n[o]=e[o]}var Ne=Autodesk.Viewing;Se(r,AutodeskNamespace("Autodesk.Viewing.MaterialConverterPrism")),Se(e,Ne.Private),Se(n,Ne.Private);var Pe=function(e){!function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Me(e,n)}(t,e);var n,o,a,r=xe(t);function t(e,n){return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),r.call(this,e,n)}return n=t,(o=[{key:"load",value:function(){return!0}},{key:"unload",value:function(){return!0}},{key:"activate",value:function(){return!0}},{key:"deactivate",value:function(){return!1}}])&&we(n.prototype,o),a&&we(n,a),t}(Ne.Extension);Ne.theExtensionManager.registerExtension("Autodesk.Viewing.MaterialConverterPrism",Pe)})(),Autodesk.Extensions.MaterialConverterPrism=a})();
//# sourceMappingURL=MaterialConverterPrism.min.js.map